{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion: Theoretical Foundation 1. Governing Equations of Motion Projectile motion follows Newton's laws of motion and assumes motion under uniform gravitational acceleration with no air resistance. The fundamental equations arise from Newton\u2019s Second Law: \\[\\mathbf{F}=m\\mathbf{a}\\] Since the only force acting on the projectile (neglecting air resistance) is gravity, we have: \\[F_y=-mg,\\quad F_x=0\\] Thus, the equations of motion can be written as: \\[m a_x=0 \\quad \\Rightarrow \\quad a_x=0\\quad m a_y=-mg \\quad \\Rightarrow \\quad a_y=-g\\] Since acceleration is the second derivative of position, we get: \\[\\frac{d^2x}{dt^2}=0,\\quad \\frac{d^2y}{dt^2}=-g\\] 2. Solving the Differential Equations Horizontal Motion Integrating the horizontal acceleration equation: \\[\\frac{dv_x}{dt}=0\\] \\[v_x=v_0\\cos\\theta\\] Since velocity is the derivative of position: \\[\\frac{dx}{dt}=v_0\\cos\\theta\\] Integrating again: \\[x(t)=v_0\\cos\\theta\\cdot t\\] Vertical Motion Integrating the vertical acceleration equation: \\[\\frac{dv_y}{dt}=-g\\] \\[v_y=v_0\\sin\\theta-gt\\] Since velocity is the derivative of position: \\[\\frac{dy}{dt}=v_0\\sin\\theta-gt\\] Integrating again: \\[y(t)=v_0\\sin\\theta\\cdot t-\\frac{1}{2} g t^2\\] 3. Range of the Projectile The range \\(R\\) is the horizontal distance the projectile travels before hitting the ground (i.e., when \\(y=0\\) ). Setting \\(y(t)=0\\) : \\[0=v_0\\sin\\theta\\cdot t-\\frac{1}{2} g t^2\\] Solving for \\(t\\) , we get: \\[t=\\frac{2 v_0\\sin\\theta}{g}\\] Substituting into the equation for \\(x(t)\\) : \\[R=v_0\\cos\\theta\\cdot\\frac{2 v_0\\sin\\theta}{g}\\] Using the identity \\(2\\sin\\theta\\cos\\theta=\\sin 2\\theta\\) , we obtain the range formula: \\[R=\\frac{v_0^2\\sin 2\\theta}{g}\\] 4. Family of Solutions and Dependence on Initial Conditions The range depends on both the initial velocity \\(v_0\\) and the launch angle \\(\\theta\\) . The maximum range occurs at \\(\\theta=45^\\circ\\) , since \\(\\sin 2\\theta\\) is maximized at \\(90^\\circ\\) . The same range can be achieved with complementary angles \\(\\theta_1\\) and \\(\\theta_2=90^\\circ-\\theta_1\\) , as \\(\\sin 2\\theta\\) is the same for both. Effect of Gravity Increasing gravity \\(g\\) decreases the range since \\(R\\propto 1/g\\) . Lower gravity environments (e.g., Moon or Mars) allow longer ranges for the same launch velocity. Effect of Initial Velocity The range is quadratic in \\(v_0\\) , meaning a slight increase in velocity results in a significantly larger range. Conclusion The projectile motion equations provide deep insight into real-world applications, from sports physics to space exploration. The range formula highlights the key dependencies on angle, velocity, and gravity, illustrating the elegance of motion under constant acceleration. Projectile Motion: Theoretical Analysis of Range 1. Relationship Between Horizontal Range and Angle of Projection The horizontal range \\(R\\) of a projectile is defined as the horizontal distance it travels before returning to its initial height. The standard equation for range, derived from kinematic equations, is: \\[R=\\frac{v_0^2\\sin 2\\theta}{g}\\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity. Effect of Angle on Range The function \\(\\sin 2\\theta\\) determines how the range varies with the angle of projection. The range is maximized when \\(\\sin 2\\theta=1\\) , which occurs at \\(\\theta=45^\\circ\\) . The same range can be obtained for complementary angles \\(\\theta\\) and \\(90^\\circ-\\theta\\) because \\(\\sin 2\\theta\\) has the same value for both. Thus, for any initial velocity, the two angles that yield the same range are given by: \\[\\theta_1+\\theta_2=90^\\circ\\] Graphical Representation The function \\(R(\\theta)\\) follows a symmetric pattern, reaching its maximum at \\(45^\\circ\\) and decreasing symmetrically for angles above and below this value. 2. Dependence of Range on Initial Velocity and Gravity Effect of Initial Velocity From the range equation: \\[R\\propto v_0^2\\] Doubling the initial velocity results in a fourfold increase in range. The relationship between range and velocity is quadratic , meaning small increases in velocity can significantly impact the range. Effect of Gravitational Acceleration From the range equation: \\[R\\propto\\frac{1}{g}\\] An increase in gravitational acceleration reduces the range. On planets with lower gravity (e.g., the Moon, Mars), a projectile launched with the same velocity and angle will travel much farther than on Earth. 3. Practical Applications of Range Analysis Sports Science In ballistics and sports like basketball, soccer, and golf, understanding range helps optimize shooting angles for maximum distance or accuracy. Athletes adjust their throwing or kicking angles based on desired projectile motion. Engineering and Defense Artillery and missile trajectory calculations rely on precise range equations to hit targets efficiently. Engineers design launch systems considering variations in \\(g\\) due to altitude or planetary conditions. Space Exploration Rocket launches consider Earth's gravity and initial velocity to optimize fuel efficiency and trajectory. Space agencies simulate projectile motion under different gravitational conditions for extraterrestrial landings. Conclusion The range of a projectile is influenced significantly by the angle of projection, initial velocity, and gravitational acceleration. The mathematical relationships governing projectile motion allow for precise predictions, leading to various applications in sports, engineering, and space exploration. Projectile Motion: Theoretical Analysis and Applications 1. Relationship Between Horizontal Range and Angle of Projection The horizontal range \\(R\\) of a projectile is defined as the horizontal distance it travels before returning to its initial height. The standard equation for range, derived from kinematic equations, is: \\[R=\\frac{v_0^2\\sin 2\\theta}{g}\\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity. Graphical Representation The function \\(R(\\theta)\\) follows a symmetric pattern, reaching its maximum at \\(45^\\circ\\) and decreasing symmetrically for angles above and below this value. Phyton \u0130mplementation import numpy as np import matplotlib.pyplot as plt class ProjectileSimulator: def __init__(self, v0, g=9.81): \"\"\" Initialize simulator with initial velocity and gravitational acceleration v0: initial velocity (m/s) g: gravitational acceleration (m/s\u00b2) \"\"\" self.v0 = v0 self.g = g def calculate_range(self, angle_deg): \"\"\" Calculate range for a given angle in degrees Returns range in meters \"\"\" # Convert angle to radians angle_rad = np.radians(angle_deg) # Range formula: R = (v0\u00b2 * sin(2\u03b8)) / g range = (self.v0**2 * np.sin(2 * angle_rad)) / self.g return range def calculate_trajectory(self, angle_deg, num_points=100): \"\"\" Calculate x, y coordinates of trajectory for a given angle Returns tuple of (x_coords, y_coords) \"\"\" angle_rad = np.radians(angle_deg) # Time of flight: t = (2 * v0 * sin(\u03b8)) / g t_flight = (2 * self.v0 * np.sin(angle_rad)) / self.g t = np.linspace(0, t_flight, num_points) # x = v0 * cos(\u03b8) * t x = self.v0 * np.cos(angle_rad) * t # y = v0 * sin(\u03b8) * t - (1/2) * g * t\u00b2 y = self.v0 * np.sin(angle_rad) * t - 0.5 * self.g * t**2 return x, y def plot_range_vs_angle(simulator, angles): \"\"\"Plot range as a function of angle\"\"\" ranges = [simulator.calculate_range(angle) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, 'b-', label=f'v0 = {simulator.v0} m/s') plt.grid(True) plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs Launch Angle') plt.legend() plt.show() def plot_trajectory(simulator, angles): \"\"\"Plot trajectories for multiple angles\"\"\" plt.figure(figsize=(12, 8)) for angle in angles: x, y = simulator.calculate_trajectory(angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.grid(True) plt.xlabel('Distance (meters)') plt.ylabel('Height (meters)') plt.title(f'Projectile Trajectories (v0 = {simulator.v0} m/s)') plt.legend() plt.axis('equal') plt.show() # Main execution if __name__ == \"__main__\": # Test different initial velocities initial_velocities = [10, 20, 30] # m/s angles = np.arange(0, 90.1, 0.5) # 0 to 90 degrees with 0.5\u00b0 steps # Plot range vs angle for different velocities plt.figure(figsize=(10, 6)) for v0 in initial_velocities: simulator = ProjectileSimulator(v0) ranges = [simulator.calculate_range(angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.grid(True) plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs Launch Angle for Different Velocities') plt.legend() plt.show() # Plot sample trajectories for one velocity sample_simulator = ProjectileSimulator(v0=20) sample_angles = [15, 30, 45, 60, 75] plot_trajectory(sample_simulator, sample_angles) Table For Range And Angle","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-theoretical-foundation","text":"","title":"Projectile Motion: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-governing-equations-of-motion","text":"Projectile motion follows Newton's laws of motion and assumes motion under uniform gravitational acceleration with no air resistance. The fundamental equations arise from Newton\u2019s Second Law: \\[\\mathbf{F}=m\\mathbf{a}\\] Since the only force acting on the projectile (neglecting air resistance) is gravity, we have: \\[F_y=-mg,\\quad F_x=0\\] Thus, the equations of motion can be written as: \\[m a_x=0 \\quad \\Rightarrow \\quad a_x=0\\quad m a_y=-mg \\quad \\Rightarrow \\quad a_y=-g\\] Since acceleration is the second derivative of position, we get: \\[\\frac{d^2x}{dt^2}=0,\\quad \\frac{d^2y}{dt^2}=-g\\]","title":"1. Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-solving-the-differential-equations","text":"","title":"2. Solving the Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Integrating the horizontal acceleration equation: \\[\\frac{dv_x}{dt}=0\\] \\[v_x=v_0\\cos\\theta\\] Since velocity is the derivative of position: \\[\\frac{dx}{dt}=v_0\\cos\\theta\\] Integrating again: \\[x(t)=v_0\\cos\\theta\\cdot t\\]","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Integrating the vertical acceleration equation: \\[\\frac{dv_y}{dt}=-g\\] \\[v_y=v_0\\sin\\theta-gt\\] Since velocity is the derivative of position: \\[\\frac{dy}{dt}=v_0\\sin\\theta-gt\\] Integrating again: \\[y(t)=v_0\\sin\\theta\\cdot t-\\frac{1}{2} g t^2\\]","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-range-of-the-projectile","text":"The range \\(R\\) is the horizontal distance the projectile travels before hitting the ground (i.e., when \\(y=0\\) ). Setting \\(y(t)=0\\) : \\[0=v_0\\sin\\theta\\cdot t-\\frac{1}{2} g t^2\\] Solving for \\(t\\) , we get: \\[t=\\frac{2 v_0\\sin\\theta}{g}\\] Substituting into the equation for \\(x(t)\\) : \\[R=v_0\\cos\\theta\\cdot\\frac{2 v_0\\sin\\theta}{g}\\] Using the identity \\(2\\sin\\theta\\cos\\theta=\\sin 2\\theta\\) , we obtain the range formula: \\[R=\\frac{v_0^2\\sin 2\\theta}{g}\\]","title":"3. Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-family-of-solutions-and-dependence-on-initial-conditions","text":"The range depends on both the initial velocity \\(v_0\\) and the launch angle \\(\\theta\\) . The maximum range occurs at \\(\\theta=45^\\circ\\) , since \\(\\sin 2\\theta\\) is maximized at \\(90^\\circ\\) . The same range can be achieved with complementary angles \\(\\theta_1\\) and \\(\\theta_2=90^\\circ-\\theta_1\\) , as \\(\\sin 2\\theta\\) is the same for both.","title":"4. Family of Solutions and Dependence on Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-gravity","text":"Increasing gravity \\(g\\) decreases the range since \\(R\\propto 1/g\\) . Lower gravity environments (e.g., Moon or Mars) allow longer ranges for the same launch velocity.","title":"Effect of Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-velocity","text":"The range is quadratic in \\(v_0\\) , meaning a slight increase in velocity results in a significantly larger range.","title":"Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The projectile motion equations provide deep insight into real-world applications, from sports physics to space exploration. The range formula highlights the key dependencies on angle, velocity, and gravity, illustrating the elegance of motion under constant acceleration.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-theoretical-analysis-of-range","text":"","title":"Projectile Motion: Theoretical Analysis of Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-relationship-between-horizontal-range-and-angle-of-projection","text":"The horizontal range \\(R\\) of a projectile is defined as the horizontal distance it travels before returning to its initial height. The standard equation for range, derived from kinematic equations, is: \\[R=\\frac{v_0^2\\sin 2\\theta}{g}\\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity.","title":"1. Relationship Between Horizontal Range and Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-angle-on-range","text":"The function \\(\\sin 2\\theta\\) determines how the range varies with the angle of projection. The range is maximized when \\(\\sin 2\\theta=1\\) , which occurs at \\(\\theta=45^\\circ\\) . The same range can be obtained for complementary angles \\(\\theta\\) and \\(90^\\circ-\\theta\\) because \\(\\sin 2\\theta\\) has the same value for both. Thus, for any initial velocity, the two angles that yield the same range are given by: \\[\\theta_1+\\theta_2=90^\\circ\\]","title":"Effect of Angle on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-representation","text":"The function \\(R(\\theta)\\) follows a symmetric pattern, reaching its maximum at \\(45^\\circ\\) and decreasing symmetrically for angles above and below this value.","title":"Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-dependence-of-range-on-initial-velocity-and-gravity","text":"","title":"2. Dependence of Range on Initial Velocity and Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-velocity_1","text":"From the range equation: \\[R\\propto v_0^2\\] Doubling the initial velocity results in a fourfold increase in range. The relationship between range and velocity is quadratic , meaning small increases in velocity can significantly impact the range.","title":"Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-gravitational-acceleration","text":"From the range equation: \\[R\\propto\\frac{1}{g}\\] An increase in gravitational acceleration reduces the range. On planets with lower gravity (e.g., the Moon, Mars), a projectile launched with the same velocity and angle will travel much farther than on Earth.","title":"Effect of Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications-of-range-analysis","text":"","title":"3. Practical Applications of Range Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#sports-science","text":"In ballistics and sports like basketball, soccer, and golf, understanding range helps optimize shooting angles for maximum distance or accuracy. Athletes adjust their throwing or kicking angles based on desired projectile motion.","title":"Sports Science"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#engineering-and-defense","text":"Artillery and missile trajectory calculations rely on precise range equations to hit targets efficiently. Engineers design launch systems considering variations in \\(g\\) due to altitude or planetary conditions.","title":"Engineering and Defense"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#space-exploration","text":"Rocket launches consider Earth's gravity and initial velocity to optimize fuel efficiency and trajectory. Space agencies simulate projectile motion under different gravitational conditions for extraterrestrial landings.","title":"Space Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion_1","text":"The range of a projectile is influenced significantly by the angle of projection, initial velocity, and gravitational acceleration. The mathematical relationships governing projectile motion allow for precise predictions, leading to various applications in sports, engineering, and space exploration.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-theoretical-analysis-and-applications","text":"","title":"Projectile Motion: Theoretical Analysis and Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-relationship-between-horizontal-range-and-angle-of-projection_1","text":"The horizontal range \\(R\\) of a projectile is defined as the horizontal distance it travels before returning to its initial height. The standard equation for range, derived from kinematic equations, is: \\[R=\\frac{v_0^2\\sin 2\\theta}{g}\\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity.","title":"1. Relationship Between Horizontal Range and Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-representation_1","text":"The function \\(R(\\theta)\\) follows a symmetric pattern, reaching its maximum at \\(45^\\circ\\) and decreasing symmetrically for angles above and below this value.","title":"Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#phyton-implementation","text":"import numpy as np import matplotlib.pyplot as plt class ProjectileSimulator: def __init__(self, v0, g=9.81): \"\"\" Initialize simulator with initial velocity and gravitational acceleration v0: initial velocity (m/s) g: gravitational acceleration (m/s\u00b2) \"\"\" self.v0 = v0 self.g = g def calculate_range(self, angle_deg): \"\"\" Calculate range for a given angle in degrees Returns range in meters \"\"\" # Convert angle to radians angle_rad = np.radians(angle_deg) # Range formula: R = (v0\u00b2 * sin(2\u03b8)) / g range = (self.v0**2 * np.sin(2 * angle_rad)) / self.g return range def calculate_trajectory(self, angle_deg, num_points=100): \"\"\" Calculate x, y coordinates of trajectory for a given angle Returns tuple of (x_coords, y_coords) \"\"\" angle_rad = np.radians(angle_deg) # Time of flight: t = (2 * v0 * sin(\u03b8)) / g t_flight = (2 * self.v0 * np.sin(angle_rad)) / self.g t = np.linspace(0, t_flight, num_points) # x = v0 * cos(\u03b8) * t x = self.v0 * np.cos(angle_rad) * t # y = v0 * sin(\u03b8) * t - (1/2) * g * t\u00b2 y = self.v0 * np.sin(angle_rad) * t - 0.5 * self.g * t**2 return x, y def plot_range_vs_angle(simulator, angles): \"\"\"Plot range as a function of angle\"\"\" ranges = [simulator.calculate_range(angle) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, 'b-', label=f'v0 = {simulator.v0} m/s') plt.grid(True) plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs Launch Angle') plt.legend() plt.show() def plot_trajectory(simulator, angles): \"\"\"Plot trajectories for multiple angles\"\"\" plt.figure(figsize=(12, 8)) for angle in angles: x, y = simulator.calculate_trajectory(angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.grid(True) plt.xlabel('Distance (meters)') plt.ylabel('Height (meters)') plt.title(f'Projectile Trajectories (v0 = {simulator.v0} m/s)') plt.legend() plt.axis('equal') plt.show() # Main execution if __name__ == \"__main__\": # Test different initial velocities initial_velocities = [10, 20, 30] # m/s angles = np.arange(0, 90.1, 0.5) # 0 to 90 degrees with 0.5\u00b0 steps # Plot range vs angle for different velocities plt.figure(figsize=(10, 6)) for v0 in initial_velocities: simulator = ProjectileSimulator(v0) ranges = [simulator.calculate_range(angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.grid(True) plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs Launch Angle for Different Velocities') plt.legend() plt.show() # Plot sample trajectories for one velocity sample_simulator = ProjectileSimulator(v0=20) sample_angles = [15, 30, 45, 60, 75] plot_trajectory(sample_simulator, sample_angles)","title":"Phyton \u0130mplementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#table-for-range-and-angle","text":"","title":"Table For Range And Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Analyzing the Behavior of a Forced Damped Pendulum 1 Theoretical Background The motion of a forced damped pendulum is described by the following second-order non-linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta(t)\\) represents the angular displacement of the pendulum from its vertical position. \\(t\\) denotes time. \\(b\\) is the damping factor (indicating energy loss). \\(g\\) is the gravitational acceleration. \\(L\\) is the pendulum's length. \\(A\\) is the amplitude of the external driving force (adjusted for mass and length). \\(\\omega\\) is the angular frequency of the applied force. 1.1 Simplified Solutions for Small-Angle Motion For small angular displacements, we can approximate \\(\\sin \\theta \\approx \\theta\\) . This transforms the equation into a linear second-order non-homogeneous form: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] where \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural angular frequency of the undamped pendulum. The complete solution to this equation includes two components: the homogeneous solution (describing transient behavior) and the particular solution (describing steady-state behavior). Homogeneous Solution: The homogeneous equation is \\(\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0\\) . The nature of the homogeneous solution depends on the discriminant of the characteristic equation \\(r^2 + br + \\omega_0^2 = 0\\) , which is \\(\\Delta = b^2 - 4\\omega_0^2\\) . Overdamped Case \\[ (b^2 > 4\\omega_0^2): \\theta_h(t) = C_1 e^{r_1 t} + C_2 e^{r_2 t}, \\] where \\(r_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4\\omega_0^2}}{2}\\) are real, negative roots. The motion decays exponentially without oscillations. Critically Damped Case \\[ (b^2 = 4\\omega_0^2): \\theta_h(t) = (C_1 + C_2 t) e^{-\\frac{b}{2} t}. \\] The motion decays as rapidly as possible without oscillating. Underdamped Case \\[ (b^2 < 4\\omega_0^2): \\theta_h(t) = e^{-\\frac{b}{2} t} (C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t)) = C e^{-\\frac{b}{2} t} \\cos(\\omega_d t - \\phi), \\] where \\(\\omega_d = \\sqrt{\\omega_0^2 - \\frac{b^2}{4}}\\) is the damped angular frequency, and \\(C\\) and \\(\\phi\\) are constants based on initial conditions. The oscillations decay exponentially with a reduced frequency compared to the natural frequency. Examining the Motion of a Forced Damped Pendulum Energy Implications: At resonance, the external driving force transfers energy to the pendulum most efficiently. The energy supplied by the driving force balances the energy lost due to damping, leading to oscillations with the highest achievable amplitude for a given driving intensity. The power provided by the driving force is calculated as: \\( P_{in}(t) = F_{drive}(t) \\cdot v(t) \\) , where \\( F_{drive}(t) = m A \\cos(\\omega t) \\) (with mass \\( m \\) implicitly factored into \\( A \\) ) and \\( v(t) = L \\frac{d\\theta}{dt} \\) . The average power input over one cycle equals the average power lost to damping, \\( P_{dissipated} = b \\left( \\frac{d\\theta}{dt} \\right)^2 \\) . At resonance, energy transfer is maximized, potentially resulting in large amplitudes if damping is low. 2 Dynamics Analysis The motion of the forced damped pendulum is significantly influenced by the damping factor ( \\( b \\) ), the driving amplitude ( \\( A \\) ), and the driving frequency ( \\( \\omega \\) ). 2.1 Effects of Parameters Damping Factor ( \\( b \\) ): Higher damping speeds up the decay of transient oscillations. Increased damping lowers the amplitude of steady-state oscillations, especially near resonance. Excessive damping can completely suppress oscillations in the homogeneous case (overdamped scenario). In the forced case, strong damping broadens the resonance peak and reduces its height. 1.2 Resonance Behavior and Energy Insights Resonance occurs when the driving frequency \\( \\omega \\) closely matches the system's natural frequency. For the forced damped pendulum (using the small-angle approximation), the amplitude of steady-state oscillations \\( \\Theta \\) reaches its maximum when the denominator in the expression for \\( \\Theta \\) is minimized. To find the resonance frequency, we differentiate the squared denominator with respect to \\( \\omega \\) and set it to zero: \\[ \\frac{d}{d\\omega} \\left[ (\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2 \\right] = 2(\\omega_0^2 - \\omega^2)(-2\\omega) + 2(b\\omega) b = 0 \\] \\[ -4\\omega (\\omega_0^2 - \\omega^2) + 2b^2\\omega = 0 \\] Assuming \\( \\omega \\neq 0 \\) , this simplifies to \\(-2(\\omega_0^2 - \\omega^2) + b^2 = 0\\) , yielding the resonance frequency \\( \\omega_r \\) : \\[ \\omega_r = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}} \\] This resonance frequency is slightly below the natural frequency \\( \\omega_0 \\) when damping exists. For minimal damping ( \\( b \\ll \\omega_0 \\) ), \\( \\omega_r \\approx \\omega_0 \\) . Energy Insights (Continued): Particular Solution (Steady-State): We propose a particular solution in the form \\( \\theta_p(t) = \\Theta \\cos(\\omega t - \\delta) \\) , where \\( \\Theta \\) is the amplitude of the forced oscillations and \\( \\delta \\) is the phase difference relative to the driving force. Substituting this into the linear equation and solving for \\( \\Theta \\) and \\( \\delta \\) yields: \\[ \\Theta = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\] \\[ \\delta = \\arctan\\left(\\frac{b\\omega}{\\omega_0^2 - \\omega^2}\\right) \\] The complete solution for small-angle oscillations combines the homogeneous and particular solutions: \\( \\theta(t) = \\theta_h(t) + \\theta_p(t) \\) . Over time, the transient homogeneous solution diminishes to zero, and the system settles into the steady-state oscillation described by \\( \\theta_p(t) \\) . Exploring the Dynamics of a Forced Damped Pendulum Driving Amplitude ( \\(A\\) ): The amplitude of the driving force directly affects the size of steady-state oscillations in the linear regime (small angles). In the non-linear regime (larger angles), a higher driving amplitude can lead to more complex behaviors, such as chaotic motion. Driving Frequency ( \\(\\omega\\) ): The driving frequency determines the tempo of the steady-state oscillations. When \\(\\omega\\) approaches the natural frequency \\(\\omega_0\\) , resonance occurs, causing large-amplitude oscillations. At frequencies significantly different from \\(\\omega_0\\) , the amplitude of oscillations tends to decrease. In the non-linear regime, varying the driving frequency may induce subharmonic or superharmonic oscillations, potentially leading to chaotic dynamics. 2.2 Shift from Regular to Chaotic Motion The forced damped pendulum is a well-known system that can display chaotic behavior. Chaos arises due to the non-linearity introduced by the \\(\\sin \\theta\\) term in the motion equation. The transition to chaos often occurs as parameters like the driving amplitude or frequency are modified. Pathways to Chaos: A common route to chaos in this system is through a sequence of period-doubling bifurcations. As a parameter is increased, the system might initially oscillate with a period \\( T = \\frac{2\\pi}{\\omega} \\) . Beyond a critical parameter value, this oscillation becomes unstable, and the system transitions to an oscillation with a period of \\( 2T \\) . Further parameter increases can cause oscillations with periods \\( 4T, 8T, 16T, \\ldots \\) , ultimately leading to chaotic motion without a clear periodic pattern. Features of Chaotic Motion: Sensitivity to Initial Conditions: Small differences in the pendulum's starting conditions result in trajectories that diverge exponentially in phase space, a phenomenon often called the \"butterfly effect.\" Non-Periodic Behavior: The motion is irregular and does not follow a predictable repeating cycle. Strange Attractors: In phase space, chaotic trajectories are confined to a bounded region called a strange attractor, which displays a complex fractal structure. Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Driving Amplitude ( \\(A\\) ): The driving amplitude directly influences the magnitude of steady-state oscillations within the linear regime (small angles). In the non-linear regime (large angles), an increase in the driving amplitude may lead to more intricate behaviors, including chaotic patterns. Driving Frequency ( \\(\\omega\\) ): The driving frequency establishes the pace of the steady-state oscillations. When \\(\\omega\\) nears the natural frequency \\(\\omega_0\\) , resonance takes place, resulting in substantial amplitude oscillations. For frequencies distant from \\(\\omega_0\\) , the oscillation amplitude typically diminishes. In the non-linear regime, different driving frequencies can trigger subharmonic or superharmonic oscillations, along with chaotic dynamics. 2.2 Transition from Regular to Chaotic Motion The forced damped pendulum exemplifies a system that can exhibit chaotic behavior. This chaos stems from the non-linear \\(\\sin \\theta\\) term in the equation of motion. The shift to chaos typically occurs as parameters such as driving amplitude or frequency are altered. Pathways to Chaos: A frequent route to chaos in this system involves a series of period-doubling bifurcations. As a parameter is increased, the system may initially oscillate with a period \\( T = \\frac{2\\pi}{\\omega} \\) . At a critical parameter threshold, this oscillation becomes unstable, leading to a transition to a period of \\( 2T \\) . Further parameter adjustments can produce oscillations with periods \\( 4T, 8T, 16T, \\ldots \\) , eventually culminating in chaotic motion lacking a defined period. Features of Chaotic Motion: Sensitivity to Initial Conditions: Slight variations in the pendulum's initial state lead to exponentially diverging paths in phase space, a phenomenon often referred to as the \"butterfly effect.\" Aperiodic Behavior: The motion is erratic and lacks a repeatable pattern. Strange Attractors: In phase space, chaotic trajectories are confined within a bounded region known as a strange attractor, characterized by a complex fractal structure. Physical Interpretations: The transition to chaos in a forced damped pendulum indicates a collapse of predictable, regular motion. The pendulum's reaction to the driving force becomes extremely sensitive to even minor perturbations, rendering long-term predictions unfeasible. This behavior is observable across various physical systems and has implications for fields ranging from weather forecasting to the stability of mechanical structures. 3 Practical Applications The forced damped pendulum model has numerous real-world applications, including: Energy Harvesting Devices: Pendulum-based energy harvesters can be designed to resonate with ambient vibrations, converting mechanical energy into electrical energy. Understanding resonance conditions and the effects of damping is vital for optimizing the efficiency of these devices. Suspension Bridges: The Tacoma Narrows Bridge collapse in 1940 is a striking example of how external periodic forces (wind) can drive a structure into resonance, leading to catastrophic failure. The principles of forced oscillations and damping are critical in the design and analysis of large structures like bridges to prevent such events. Oscillating Circuits (RLC Circuits): The behavior of a driven RLC circuit is mathematically analogous to a forced damped mechanical oscillator. The charge on the capacitor or the current in the inductor oscillates in response to a periodic voltage source. Resonance phenomena in RLC circuits are fundamental to radio tuning and filter design. Mechanical Metronomes: These devices use a pendulum to provide a regular beat for music. The damping ensures that the oscillations decay slowly, and the driving force (often through a clockwork mechanism) maintains a consistent amplitude. Seismology: The response of buildings and other structures to seismic waves can be modeled as forced damped oscillations. Understanding the natural frequencies of structures and the frequencies present in earthquakes is crucial for designing earthquake-resistant buildings. Biomechanics (Human Gait): The motion of limbs during walking or running can be approximated as damped oscillations driven by muscle forces. The concepts of resonance and energy efficiency are relevant in understanding human locomotion. Climate Systems: While much more complex, some aspects of climate variability can be conceptualized as oscillations driven by periodic forcing (e.g., solar radiation) and influenced by damping mechanisms (e.g., heat dissipation). 4 Implementation We will now develop a computational model of the forced damped pendulum using Python. We will employ the scipy.integrate.solve_ivp function to numerically solve the second-order differential equation and matplotlib for visualization. ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Define the parameters of the pendulum L = 1.0 # Length of the pendulum (m) g = 9.81 # Acceleration due to gravity (m/s^2) def pendulum_equation(t, y, b, A, omega): \"\"\" Defines the differential equation for the forced damped pendulum. Args: t (float): Time. y (numpy.ndarray): Array containing the angular displacement (theta) and angular velocity (dtheta/dt). b (float): Damping coefficient. A (float): Driving amplitude. omega (float): Driving frequency. Returns: numpy.ndarray: Array containing the derivatives dtheta/dt and d^2theta/dt^2. \"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] def simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b, A, omega): \"\"\" Simulates the motion of the forced damped pendulum. Args: initial_angle (float): Initial angular displacement (radians). initial_velocity (float): Initial angular velocity (radians/s). t_span (tuple): Time interval of the simulation (start, end). t_eval (numpy.ndarray): Array of time points at which to store the solution. b (float): Damping coefficient. A (float): Driving amplitude. omega (float): Driving frequency. Returns: scipy.integrate.OdeResult: Object containing the solution. \"\"\" initial_conditions = [initial_angle, initial_velocity] solution = solve_ivp(pendulum_equation, t_span, initial_conditions, t_eval=t_eval, args=(b, A, omega), dense_output=True, rtol=1e-8, atol=1e-8) return solution def plot_motion(t, theta, title): \"\"\" Plots the angular displacement as a function of time. Args: t (numpy.ndarray): Time array. theta (numpy.ndarray): Angular displacement array. title (str): Title of the plot. \"\"\" plt.figure(figsize=(10, 6)) plt.plot(t, theta) plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(title) plt.grid(True) plt.show() def plot_phase_diagram(theta, omega_dot, title): \"\"\" Plots the phase diagram (angular velocity vs. angular displacement). Args: theta (numpy.ndarray): Angular displacement array. omega_dot (numpy.ndarray): Angular velocity array. title (str): Title of the plot. \"\"\" plt.figure(figsize=(8, 8)) plt.plot(theta, omega_dot) plt.xlabel(\"Angular Displacement (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(title) plt.grid(True) plt.show() def plot_poincare_section(t, theta, omega_dot, driving_period, title): \"\"\" Plots the Poincar\u00e9 section by sampling points at integer multiples of the driving period. Args: t (numpy.ndarray): Time array. theta (numpy.ndarray): Angular displacement array. omega_dot (numpy.ndarray): Angular velocity array. driving_period (float): Period of the driving force (2*pi/omega). title (str): Title of the plot. \"\"\" poincare_theta = poincare_omega_dot = for i, time in enumerate(t): if np.isclose(time % driving_period, 0.0, atol=1e-3): poincare_theta.append(theta[i]) poincare_omega_dot.append(omega_dot[i]) plt.figure(figsize=(8, 8)) plt.scatter(poincare_theta, poincare_omega_dot, s=5) plt.xlabel(\"Angular Displacement (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(title) plt.grid(True) plt.show() if name == \" main \": # Example parameters initial_angle = 0.1 # radians initial_velocity = 0.0 # radians/s t_span = (0, 100) # Simulation time span (seconds) t_eval = np.linspace(t_span[0], t_span[1], 10000) # Case 1: Underdamped, no driving force b1 = 0.1 A1 = 0.0 omega1 = np.sqrt(g / L) # Natural frequency sol1 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b1, A1, omega1) plot_motion(sol1.t, sol1.y[0], \"Underdamped Pendulum (No Driving)\") plot_phase_diagram(sol1.y[0], sol1.y[1], \"Phase Diagram: Underdamped Pendulum (No Driving)\") # Case 2: Driven pendulum near resonance b2 = 0.5 A2 = 0.5 omega2 = np.sqrt(g / L) # Driving at natural frequency sol2 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b2, A2, omega2) plot_motion(sol2.t, sol2.y[0], \"Driven Pendulum Near Resonance\") plot_phase_diagram(sol2.y[0], sol2.y[1], \"Phase Diagram: Driven Pendulum Near Resonance\") # Case 3: Driven pendulum with higher damping b3 = 2.0 A3 = 0.5 omega3 = np.sqrt(g / L) sol3 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b3, A3, omega3) plot_motion(sol3.t, sol3.y[0], \"Driven Pendulum with Higher Damping\") plot_phase_diagram(sol3.y[0], sol3.y[1], \"Phase Diagram: Driven Pendulum with Higher Damping\") # Case 4: Potential for chaotic behavior (higher driving amplitude and different frequency) b4 = 0.2 A4 = 1.2 omega4 = 0.8 * np.sqrt(g / L) sol4 = simulate_pendulum(initial_angle, initial_velocity, (0, 300), np.linspace(0, 300, 30000), b4, A4, omega4) plot_motion(sol4.t, sol4.y[0], \"Potentially Chaotic Driven Pendulum\") plot_phase_diagram(sol4.y[0], sol4.y[1], \"Phase Diagram: Potentially Chaotic Driven Pendulum\") driving_period4 = 2 * np.pi / omega4 plot_poincare_section(sol4.t, sol4.y[0], sol4.y[1], driving_period4, \"Poincar\u00e9 Section: Potentially Chaotic Driven Pendulum\") ``` # **Python Script for Forced Damped Pendulum Simulation** This Python script defines the differential equation for the forced damped pendulum and provides functions to simulate its motion, plot the angular displacement over time, plot the phase diagram, and generate a Poincar\u00e9 section. The if __name__ == \"__main__\": block demonstrates simulations for different parameter sets, including cases with no driving, driving near resonance, higher damping, and parameters that might lead to chaotic behavior. To observe the transition to chaos more systematically, one could vary a parameter (e.g., driving amplitude A ) and observe the changes in the phase diagrams and Poincar\u00e9 sections. For regular periodic motion, the Poincar\u00e9 section will consist of a few discrete points. As the system approaches chaos, the number of points increases, and they can form complex patterns indicative of a strange attractor.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analyzing-the-behavior-of-a-forced-damped-pendulum","text":"","title":"Analyzing the Behavior of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-background","text":"The motion of a forced damped pendulum is described by the following second-order non-linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta(t)\\) represents the angular displacement of the pendulum from its vertical position. \\(t\\) denotes time. \\(b\\) is the damping factor (indicating energy loss). \\(g\\) is the gravitational acceleration. \\(L\\) is the pendulum's length. \\(A\\) is the amplitude of the external driving force (adjusted for mass and length). \\(\\omega\\) is the angular frequency of the applied force.","title":"1 Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-simplified-solutions-for-small-angle-motion","text":"For small angular displacements, we can approximate \\(\\sin \\theta \\approx \\theta\\) . This transforms the equation into a linear second-order non-homogeneous form: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] where \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural angular frequency of the undamped pendulum. The complete solution to this equation includes two components: the homogeneous solution (describing transient behavior) and the particular solution (describing steady-state behavior).","title":"1.1 Simplified Solutions for Small-Angle Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#homogeneous-solution","text":"The homogeneous equation is \\(\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0\\) . The nature of the homogeneous solution depends on the discriminant of the characteristic equation \\(r^2 + br + \\omega_0^2 = 0\\) , which is \\(\\Delta = b^2 - 4\\omega_0^2\\) .","title":"Homogeneous Solution:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#overdamped-case","text":"\\[ (b^2 > 4\\omega_0^2): \\theta_h(t) = C_1 e^{r_1 t} + C_2 e^{r_2 t}, \\] where \\(r_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4\\omega_0^2}}{2}\\) are real, negative roots. The motion decays exponentially without oscillations.","title":"Overdamped Case"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#critically-damped-case","text":"\\[ (b^2 = 4\\omega_0^2): \\theta_h(t) = (C_1 + C_2 t) e^{-\\frac{b}{2} t}. \\] The motion decays as rapidly as possible without oscillating.","title":"Critically Damped Case"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#underdamped-case","text":"\\[ (b^2 < 4\\omega_0^2): \\theta_h(t) = e^{-\\frac{b}{2} t} (C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t)) = C e^{-\\frac{b}{2} t} \\cos(\\omega_d t - \\phi), \\] where \\(\\omega_d = \\sqrt{\\omega_0^2 - \\frac{b^2}{4}}\\) is the damped angular frequency, and \\(C\\) and \\(\\phi\\) are constants based on initial conditions. The oscillations decay exponentially with a reduced frequency compared to the natural frequency.","title":"Underdamped Case"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#examining-the-motion-of-a-forced-damped-pendulum","text":"","title":"Examining the Motion of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-implications","text":"At resonance, the external driving force transfers energy to the pendulum most efficiently. The energy supplied by the driving force balances the energy lost due to damping, leading to oscillations with the highest achievable amplitude for a given driving intensity. The power provided by the driving force is calculated as: \\( P_{in}(t) = F_{drive}(t) \\cdot v(t) \\) , where \\( F_{drive}(t) = m A \\cos(\\omega t) \\) (with mass \\( m \\) implicitly factored into \\( A \\) ) and \\( v(t) = L \\frac{d\\theta}{dt} \\) . The average power input over one cycle equals the average power lost to damping, \\( P_{dissipated} = b \\left( \\frac{d\\theta}{dt} \\right)^2 \\) . At resonance, energy transfer is maximized, potentially resulting in large amplitudes if damping is low.","title":"Energy Implications:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-dynamics-analysis","text":"The motion of the forced damped pendulum is significantly influenced by the damping factor ( \\( b \\) ), the driving amplitude ( \\( A \\) ), and the driving frequency ( \\( \\omega \\) ).","title":"2 Dynamics Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-effects-of-parameters","text":"Damping Factor ( \\( b \\) ): Higher damping speeds up the decay of transient oscillations. Increased damping lowers the amplitude of steady-state oscillations, especially near resonance. Excessive damping can completely suppress oscillations in the homogeneous case (overdamped scenario). In the forced case, strong damping broadens the resonance peak and reduces its height.","title":"2.1 Effects of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-resonance-behavior-and-energy-insights","text":"Resonance occurs when the driving frequency \\( \\omega \\) closely matches the system's natural frequency. For the forced damped pendulum (using the small-angle approximation), the amplitude of steady-state oscillations \\( \\Theta \\) reaches its maximum when the denominator in the expression for \\( \\Theta \\) is minimized. To find the resonance frequency, we differentiate the squared denominator with respect to \\( \\omega \\) and set it to zero: \\[ \\frac{d}{d\\omega} \\left[ (\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2 \\right] = 2(\\omega_0^2 - \\omega^2)(-2\\omega) + 2(b\\omega) b = 0 \\] \\[ -4\\omega (\\omega_0^2 - \\omega^2) + 2b^2\\omega = 0 \\] Assuming \\( \\omega \\neq 0 \\) , this simplifies to \\(-2(\\omega_0^2 - \\omega^2) + b^2 = 0\\) , yielding the resonance frequency \\( \\omega_r \\) : \\[ \\omega_r = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}} \\] This resonance frequency is slightly below the natural frequency \\( \\omega_0 \\) when damping exists. For minimal damping ( \\( b \\ll \\omega_0 \\) ), \\( \\omega_r \\approx \\omega_0 \\) .","title":"1.2 Resonance Behavior and Energy Insights"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-insights-continued","text":"","title":"Energy Insights (Continued):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#particular-solution-steady-state","text":"We propose a particular solution in the form \\( \\theta_p(t) = \\Theta \\cos(\\omega t - \\delta) \\) , where \\( \\Theta \\) is the amplitude of the forced oscillations and \\( \\delta \\) is the phase difference relative to the driving force. Substituting this into the linear equation and solving for \\( \\Theta \\) and \\( \\delta \\) yields: \\[ \\Theta = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\] \\[ \\delta = \\arctan\\left(\\frac{b\\omega}{\\omega_0^2 - \\omega^2}\\right) \\] The complete solution for small-angle oscillations combines the homogeneous and particular solutions: \\( \\theta(t) = \\theta_h(t) + \\theta_p(t) \\) . Over time, the transient homogeneous solution diminishes to zero, and the system settles into the steady-state oscillation described by \\( \\theta_p(t) \\) .","title":"Particular Solution (Steady-State):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#exploring-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Exploring the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-amplitude-a","text":"The amplitude of the driving force directly affects the size of steady-state oscillations in the linear regime (small angles). In the non-linear regime (larger angles), a higher driving amplitude can lead to more complex behaviors, such as chaotic motion.","title":"Driving Amplitude (\\(A\\)):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-frequency-omega","text":"The driving frequency determines the tempo of the steady-state oscillations. When \\(\\omega\\) approaches the natural frequency \\(\\omega_0\\) , resonance occurs, causing large-amplitude oscillations. At frequencies significantly different from \\(\\omega_0\\) , the amplitude of oscillations tends to decrease. In the non-linear regime, varying the driving frequency may induce subharmonic or superharmonic oscillations, potentially leading to chaotic dynamics.","title":"Driving Frequency (\\(\\omega\\)):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-shift-from-regular-to-chaotic-motion","text":"The forced damped pendulum is a well-known system that can display chaotic behavior. Chaos arises due to the non-linearity introduced by the \\(\\sin \\theta\\) term in the motion equation. The transition to chaos often occurs as parameters like the driving amplitude or frequency are modified.","title":"2.2 Shift from Regular to Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pathways-to-chaos","text":"A common route to chaos in this system is through a sequence of period-doubling bifurcations. As a parameter is increased, the system might initially oscillate with a period \\( T = \\frac{2\\pi}{\\omega} \\) . Beyond a critical parameter value, this oscillation becomes unstable, and the system transitions to an oscillation with a period of \\( 2T \\) . Further parameter increases can cause oscillations with periods \\( 4T, 8T, 16T, \\ldots \\) , ultimately leading to chaotic motion without a clear periodic pattern.","title":"Pathways to Chaos:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#features-of-chaotic-motion","text":"Sensitivity to Initial Conditions: Small differences in the pendulum's starting conditions result in trajectories that diverge exponentially in phase space, a phenomenon often called the \"butterfly effect.\" Non-Periodic Behavior: The motion is irregular and does not follow a predictable repeating cycle. Strange Attractors: In phase space, chaotic trajectories are confined to a bounded region called a strange attractor, which displays a complex fractal structure.","title":"Features of Chaotic Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2_1","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-amplitude-a_1","text":"The driving amplitude directly influences the magnitude of steady-state oscillations within the linear regime (small angles). In the non-linear regime (large angles), an increase in the driving amplitude may lead to more intricate behaviors, including chaotic patterns.","title":"Driving Amplitude (\\(A\\)):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-frequency-omega_1","text":"The driving frequency establishes the pace of the steady-state oscillations. When \\(\\omega\\) nears the natural frequency \\(\\omega_0\\) , resonance takes place, resulting in substantial amplitude oscillations. For frequencies distant from \\(\\omega_0\\) , the oscillation amplitude typically diminishes. In the non-linear regime, different driving frequencies can trigger subharmonic or superharmonic oscillations, along with chaotic dynamics.","title":"Driving Frequency (\\(\\omega\\)):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-transition-from-regular-to-chaotic-motion","text":"The forced damped pendulum exemplifies a system that can exhibit chaotic behavior. This chaos stems from the non-linear \\(\\sin \\theta\\) term in the equation of motion. The shift to chaos typically occurs as parameters such as driving amplitude or frequency are altered.","title":"2.2 Transition from Regular to Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pathways-to-chaos_1","text":"A frequent route to chaos in this system involves a series of period-doubling bifurcations. As a parameter is increased, the system may initially oscillate with a period \\( T = \\frac{2\\pi}{\\omega} \\) . At a critical parameter threshold, this oscillation becomes unstable, leading to a transition to a period of \\( 2T \\) . Further parameter adjustments can produce oscillations with periods \\( 4T, 8T, 16T, \\ldots \\) , eventually culminating in chaotic motion lacking a defined period.","title":"Pathways to Chaos:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#features-of-chaotic-motion_1","text":"Sensitivity to Initial Conditions: Slight variations in the pendulum's initial state lead to exponentially diverging paths in phase space, a phenomenon often referred to as the \"butterfly effect.\" Aperiodic Behavior: The motion is erratic and lacks a repeatable pattern. Strange Attractors: In phase space, chaotic trajectories are confined within a bounded region known as a strange attractor, characterized by a complex fractal structure.","title":"Features of Chaotic Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physical-interpretations","text":"The transition to chaos in a forced damped pendulum indicates a collapse of predictable, regular motion. The pendulum's reaction to the driving force becomes extremely sensitive to even minor perturbations, rendering long-term predictions unfeasible. This behavior is observable across various physical systems and has implications for fields ranging from weather forecasting to the stability of mechanical structures.","title":"Physical Interpretations:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model has numerous real-world applications, including: Energy Harvesting Devices: Pendulum-based energy harvesters can be designed to resonate with ambient vibrations, converting mechanical energy into electrical energy. Understanding resonance conditions and the effects of damping is vital for optimizing the efficiency of these devices. Suspension Bridges: The Tacoma Narrows Bridge collapse in 1940 is a striking example of how external periodic forces (wind) can drive a structure into resonance, leading to catastrophic failure. The principles of forced oscillations and damping are critical in the design and analysis of large structures like bridges to prevent such events. Oscillating Circuits (RLC Circuits): The behavior of a driven RLC circuit is mathematically analogous to a forced damped mechanical oscillator. The charge on the capacitor or the current in the inductor oscillates in response to a periodic voltage source. Resonance phenomena in RLC circuits are fundamental to radio tuning and filter design. Mechanical Metronomes: These devices use a pendulum to provide a regular beat for music. The damping ensures that the oscillations decay slowly, and the driving force (often through a clockwork mechanism) maintains a consistent amplitude. Seismology: The response of buildings and other structures to seismic waves can be modeled as forced damped oscillations. Understanding the natural frequencies of structures and the frequencies present in earthquakes is crucial for designing earthquake-resistant buildings. Biomechanics (Human Gait): The motion of limbs during walking or running can be approximated as damped oscillations driven by muscle forces. The concepts of resonance and energy efficiency are relevant in understanding human locomotion. Climate Systems: While much more complex, some aspects of climate variability can be conceptualized as oscillations driven by periodic forcing (e.g., solar radiation) and influenced by damping mechanisms (e.g., heat dissipation).","title":"3 Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"We will now develop a computational model of the forced damped pendulum using Python. We will employ the scipy.integrate.solve_ivp function to numerically solve the second-order differential equation and matplotlib for visualization. ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"4 Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#define-the-parameters-of-the-pendulum","text":"L = 1.0 # Length of the pendulum (m) g = 9.81 # Acceleration due to gravity (m/s^2) def pendulum_equation(t, y, b, A, omega): \"\"\" Defines the differential equation for the forced damped pendulum. Args: t (float): Time. y (numpy.ndarray): Array containing the angular displacement (theta) and angular velocity (dtheta/dt). b (float): Damping coefficient. A (float): Driving amplitude. omega (float): Driving frequency. Returns: numpy.ndarray: Array containing the derivatives dtheta/dt and d^2theta/dt^2. \"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] def simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b, A, omega): \"\"\" Simulates the motion of the forced damped pendulum. Args: initial_angle (float): Initial angular displacement (radians). initial_velocity (float): Initial angular velocity (radians/s). t_span (tuple): Time interval of the simulation (start, end). t_eval (numpy.ndarray): Array of time points at which to store the solution. b (float): Damping coefficient. A (float): Driving amplitude. omega (float): Driving frequency. Returns: scipy.integrate.OdeResult: Object containing the solution. \"\"\" initial_conditions = [initial_angle, initial_velocity] solution = solve_ivp(pendulum_equation, t_span, initial_conditions, t_eval=t_eval, args=(b, A, omega), dense_output=True, rtol=1e-8, atol=1e-8) return solution def plot_motion(t, theta, title): \"\"\" Plots the angular displacement as a function of time. Args: t (numpy.ndarray): Time array. theta (numpy.ndarray): Angular displacement array. title (str): Title of the plot. \"\"\" plt.figure(figsize=(10, 6)) plt.plot(t, theta) plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(title) plt.grid(True) plt.show() def plot_phase_diagram(theta, omega_dot, title): \"\"\" Plots the phase diagram (angular velocity vs. angular displacement). Args: theta (numpy.ndarray): Angular displacement array. omega_dot (numpy.ndarray): Angular velocity array. title (str): Title of the plot. \"\"\" plt.figure(figsize=(8, 8)) plt.plot(theta, omega_dot) plt.xlabel(\"Angular Displacement (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(title) plt.grid(True) plt.show() def plot_poincare_section(t, theta, omega_dot, driving_period, title): \"\"\" Plots the Poincar\u00e9 section by sampling points at integer multiples of the driving period. Args: t (numpy.ndarray): Time array. theta (numpy.ndarray): Angular displacement array. omega_dot (numpy.ndarray): Angular velocity array. driving_period (float): Period of the driving force (2*pi/omega). title (str): Title of the plot. \"\"\" poincare_theta = poincare_omega_dot = for i, time in enumerate(t): if np.isclose(time % driving_period, 0.0, atol=1e-3): poincare_theta.append(theta[i]) poincare_omega_dot.append(omega_dot[i]) plt.figure(figsize=(8, 8)) plt.scatter(poincare_theta, poincare_omega_dot, s=5) plt.xlabel(\"Angular Displacement (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(title) plt.grid(True) plt.show() if name == \" main \": # Example parameters initial_angle = 0.1 # radians initial_velocity = 0.0 # radians/s t_span = (0, 100) # Simulation time span (seconds) t_eval = np.linspace(t_span[0], t_span[1], 10000) # Case 1: Underdamped, no driving force b1 = 0.1 A1 = 0.0 omega1 = np.sqrt(g / L) # Natural frequency sol1 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b1, A1, omega1) plot_motion(sol1.t, sol1.y[0], \"Underdamped Pendulum (No Driving)\") plot_phase_diagram(sol1.y[0], sol1.y[1], \"Phase Diagram: Underdamped Pendulum (No Driving)\") # Case 2: Driven pendulum near resonance b2 = 0.5 A2 = 0.5 omega2 = np.sqrt(g / L) # Driving at natural frequency sol2 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b2, A2, omega2) plot_motion(sol2.t, sol2.y[0], \"Driven Pendulum Near Resonance\") plot_phase_diagram(sol2.y[0], sol2.y[1], \"Phase Diagram: Driven Pendulum Near Resonance\") # Case 3: Driven pendulum with higher damping b3 = 2.0 A3 = 0.5 omega3 = np.sqrt(g / L) sol3 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b3, A3, omega3) plot_motion(sol3.t, sol3.y[0], \"Driven Pendulum with Higher Damping\") plot_phase_diagram(sol3.y[0], sol3.y[1], \"Phase Diagram: Driven Pendulum with Higher Damping\") # Case 4: Potential for chaotic behavior (higher driving amplitude and different frequency) b4 = 0.2 A4 = 1.2 omega4 = 0.8 * np.sqrt(g / L) sol4 = simulate_pendulum(initial_angle, initial_velocity, (0, 300), np.linspace(0, 300, 30000), b4, A4, omega4) plot_motion(sol4.t, sol4.y[0], \"Potentially Chaotic Driven Pendulum\") plot_phase_diagram(sol4.y[0], sol4.y[1], \"Phase Diagram: Potentially Chaotic Driven Pendulum\") driving_period4 = 2 * np.pi / omega4 plot_poincare_section(sol4.t, sol4.y[0], sol4.y[1], driving_period4, \"Poincar\u00e9 Section: Potentially Chaotic Driven Pendulum\") ``` # **Python Script for Forced Damped Pendulum Simulation** This Python script defines the differential equation for the forced damped pendulum and provides functions to simulate its motion, plot the angular displacement over time, plot the phase diagram, and generate a Poincar\u00e9 section. The if __name__ == \"__main__\": block demonstrates simulations for different parameter sets, including cases with no driving, driving near resonance, higher damping, and parameters that might lead to chaotic behavior. To observe the transition to chaos more systematically, one could vary a parameter (e.g., driving amplitude A ) and observe the changes in the phase diagrams and Poincar\u00e9 sections. For regular periodic motion, the Poincar\u00e9 section will consist of a few discrete points. As the system approaches chaos, the number of points increases, and they can form complex patterns indicative of a strange attractor.","title":"Define the parameters of the pendulum"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Task 1. Derivation of the Relationship for Circular Orbits Consider an object of mass \\(m\\) (e.g., a planet or a satellite) orbiting a much larger object of mass \\(M\\) (e.g., a star or a planet) in a circular orbit of radius \\(r\\) with an orbital period \\(T\\) . The gravitational force between the two objects provides the centripetal force required for the circular motion. According to Newton's Law of Universal Gravitation , the gravitational force \\(F_g\\) is given by: \\[F_g = G \\frac{Mm}{r^2}\\] where \\(G\\) is the gravitational constant. The centripetal force \\(F_c\\) required to keep the object of mass \\(m\\) moving in a circle of radius \\(r\\) with a speed \\(v\\) is given by: \\[F_c = \\frac{mv^2}{r}\\] For a stable circular orbit, the gravitational force must equal the centripetal force: \\[G \\frac{Mm}{r^2} = \\frac{mv^2}{r}\\] We can cancel the mass of the orbiting object \\(m\\) from both sides: \\[G \\frac{M}{r^2} = \\frac{v^2}{r}\\] The speed \\(v\\) of the orbiting object is related to the orbital radius \\(r\\) and the orbital period \\(T\\) by the formula: \\[v = \\frac{2\\pi r}{T}\\] Substituting this expression for \\(v\\) into the equation above: \\[G \\frac{M}{r^2} = \\frac{(2\\pi r/T)^2}{r}\\] Simplify the equation: \\[G \\frac{M}{r^2} = \\frac{4\\pi^2 r^2}{T^2 r}$$ $$G \\frac{M}{r^2} = \\frac{4\\pi^2 r}{T^2}\\] Now, rearrange the equation to solve for \\(T^2\\) : \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] This equation shows that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) , with the constant of proportionality being \\(\\frac{4\\pi^2}{GM}\\) . This is Kepler's Third Law for circular orbits. 2. Implications for Astronomy Kepler's Third Law has several crucial implications for astronomy: Determining the Mass of a Central Body: If we know the orbital period \\(T\\) and the orbital radius \\(r\\) of an object orbiting a central body, we can calculate the mass \\(M\\) of the central body using the rearranged formula: \\[M = \\frac{4\\pi^2 r^3}{GT^2}\\] This is how the masses of stars, planets, and even black holes can be estimated by observing the orbits of their satellites or companion stars. Predicting Orbital Periods and Radii: Conversely, if we know the mass of the central body and either the orbital period or the orbital radius of an orbiting object, we can predict the other quantity. This is essential for planning satellite missions and understanding the dynamics of planetary systems. Understanding Planetary Systems: Kepler's Third Law provides a fundamental framework for understanding the structure and evolution of planetary systems. The consistent relationship between orbital periods and radii across different planets in a system supports the idea of a common formation mechanism. 3. Real-world Examples Let's consider two examples: the Moon orbiting the Earth and the Earth orbiting the Sun. The Moon Orbiting the Earth: Orbital Period of the Moon ( \\(T_{\\text{Moon}}\\) ): \\(\\approx 27.3 \\text{ days} \\approx 27.3 \\times 24 \\times 3600 \\text{ seconds} \\approx 2.36 \\times 10^6 \\text{ s}\\) Average orbital radius of the Moon ( \\(r_{\\text{Moon}}\\) ): \\(\\approx 384,400 \\text{ km} \\approx 3.844 \\times 10^8 \\text{ m}\\) Mass of the Earth ( \\(M_{\\text{Earth}}\\) ): \\(\\approx 5.972 \\times 10^{24} \\text{ kg}\\) Gravitational constant ( \\(G\\) ): \\(\\approx 6.674 \\times 10^{-11} \\text{ N}\\cdot\\text{m}^2/\\text{kg}^2\\) Let's verify Kepler's Third Law using these values. Calculate \\(\\frac{4\\pi^2 r^3_{\\text{Moon}}}{GM_{\\text{Earth}}}\\) : \\[\\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})} \\approx \\frac{4 \\times (3.14159)^2 \\times 5.66 \\times 10^{25}}{3.985 \\times 10^{14}} \\approx 5.62 \\times 10^{12} \\text{ s}^2\\] Now, let's calculate \\(T^2_{\\text{Moon}}\\) : \\[(2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12} \\text{ s}^2\\] The calculated value from Kepler's Third Law is very close to the square of the Moon's orbital period, confirming the law. The Earth Orbiting the Sun: Orbital Period of the Earth ( \\(T_{\\text{Earth}}\\) ): \\(\\approx 365.25 \\text{ days} \\approx 365.25 \\times 24 \\times 3600 \\text{ seconds} \\approx 3.156 \\times 10^7 \\text{ s}\\) Average orbital radius of the Earth ( \\(r_{\\text{Earth}}\\) ): \\(\\approx 1.496 \\times 10^{11} \\text{ m}\\) Mass of the Sun ( \\(M_{\\text{Sun}}\\) ): \\(\\approx 1.989 \\times 10^{30} \\text{ kg}\\) Calculate \\(\\frac{4\\pi^2 r^3_{\\text{Earth}}}{GM_{\\text{Sun}}}\\) : \\[\\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.674 \\times 10^{-11})(1.989 \\times 10^{30})} \\approx \\frac{4 \\times (3.14159)^2 \\times 3.348 \\times 10^{33}}{1.327 \\times 10^{20}} \\approx 1.00 \\times 10^{15} \\text{ s}^2\\] Now, let's calculate \\(T^2_{\\text{Earth}}\\) : \\[(3.156 \\times 10^7)^2 \\approx 9.96 \\times 10^{14} \\text{ s}^2\\] Again, the calculated value is very close to the square of the Earth's orbital period, validating Kepler's Third Law. 4. Computational Model We can create a simplified computational model using Python to simulate circular orbits and observe the relationship between orbital period and radius. Below is an example Python script: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (N\u00b7m\u00b2/kg\u00b2) M = 1.989 * 10**30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(r): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Radii for the curve radii = np.linspace(1e10, 5e12, 100) # in meters T_squared = (orbital_period(radii))**2 r_cubed = radii**3 # Planetary data (semi-major axis in meters, orbital period in seconds) planets = { \"Mercury\": (5.79e10, 7.6e6), \"Venus\": (1.082e11, 1.94e7), \"Earth\": (1.496e11, 3.156e7), \"Mars\": (2.279e11, 5.93e7), \"Jupiter\": (7.785e11, 3.74e8) } # Prepare planet data for plotting planet_r_cubed = [r**3 for r, T in planets.values()] planet_T_squared = [T**2 for r, T in planets.values()] # Plot T^2 vs r^3 on a log-log scale plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=\"T\u00b2 vs r\u00b3 (Kepler's Law)\", color='blue') plt.scatter(planet_r_cubed, planet_T_squared, color='red', s=50, label=\"Planets\", zorder=5) # Add planet labels for name, (r, T) in planets.items(): plt.text(r**3, T**2, name, fontsize=9, ha='right') plt.xscale('log') plt.yscale('log') plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True, which='both', ls='--') plt.legend() plt.tight_layout() plt.show() This plot demonstrates the linear relationship between the square of the orbital period and the cube of the orbital radius, visually confirming Kepler's Third Law. The slope of the linear fit is proportional to \\(1/(GM)\\) . The Python code calculates and plots the relationship between the radius and the period, and also plots the square of the period against the cube of the radius to demonstrate the linear relationship predicted by Kepler's Third Law. The linear fit to the \\(T^2\\) vs \\(r^3\\) plot will have a slope equal to \\(\\frac{4\\pi^2}{GM}\\) . 5. Extension to Elliptical Orbits For elliptical orbits, Kepler's Third Law still holds, but the radius \\(r\\) is replaced by the semi-major axis \\(a\\) of the ellipse. The semi-major axis is half of the longest diameter of the ellipse and is the average of the perihelion (closest approach) and aphelion (farthest distance) distances. The law can be written as: \\[T^2 = \\frac{4\\pi^2 a^3}{GM}\\] where \\(a\\) is the length of the semi-major axis. This extension is crucial for understanding the orbits of planets, comets, and many other celestial bodies that do not follow perfectly circular paths. The derivation for elliptical orbits involves more advanced mathematics and takes into account the varying speed of the orbiting object as it moves along its elliptical path, as described by Kepler's Second Law (the law of equal areas).","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-the-relationship-for-circular-orbits","text":"Consider an object of mass \\(m\\) (e.g., a planet or a satellite) orbiting a much larger object of mass \\(M\\) (e.g., a star or a planet) in a circular orbit of radius \\(r\\) with an orbital period \\(T\\) . The gravitational force between the two objects provides the centripetal force required for the circular motion. According to Newton's Law of Universal Gravitation , the gravitational force \\(F_g\\) is given by: \\[F_g = G \\frac{Mm}{r^2}\\] where \\(G\\) is the gravitational constant. The centripetal force \\(F_c\\) required to keep the object of mass \\(m\\) moving in a circle of radius \\(r\\) with a speed \\(v\\) is given by: \\[F_c = \\frac{mv^2}{r}\\] For a stable circular orbit, the gravitational force must equal the centripetal force: \\[G \\frac{Mm}{r^2} = \\frac{mv^2}{r}\\] We can cancel the mass of the orbiting object \\(m\\) from both sides: \\[G \\frac{M}{r^2} = \\frac{v^2}{r}\\] The speed \\(v\\) of the orbiting object is related to the orbital radius \\(r\\) and the orbital period \\(T\\) by the formula: \\[v = \\frac{2\\pi r}{T}\\] Substituting this expression for \\(v\\) into the equation above: \\[G \\frac{M}{r^2} = \\frac{(2\\pi r/T)^2}{r}\\] Simplify the equation: \\[G \\frac{M}{r^2} = \\frac{4\\pi^2 r^2}{T^2 r}$$ $$G \\frac{M}{r^2} = \\frac{4\\pi^2 r}{T^2}\\] Now, rearrange the equation to solve for \\(T^2\\) : \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] This equation shows that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) , with the constant of proportionality being \\(\\frac{4\\pi^2}{GM}\\) . This is Kepler's Third Law for circular orbits.","title":"1. Derivation of the Relationship for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler's Third Law has several crucial implications for astronomy: Determining the Mass of a Central Body: If we know the orbital period \\(T\\) and the orbital radius \\(r\\) of an object orbiting a central body, we can calculate the mass \\(M\\) of the central body using the rearranged formula: \\[M = \\frac{4\\pi^2 r^3}{GT^2}\\] This is how the masses of stars, planets, and even black holes can be estimated by observing the orbits of their satellites or companion stars. Predicting Orbital Periods and Radii: Conversely, if we know the mass of the central body and either the orbital period or the orbital radius of an orbiting object, we can predict the other quantity. This is essential for planning satellite missions and understanding the dynamics of planetary systems. Understanding Planetary Systems: Kepler's Third Law provides a fundamental framework for understanding the structure and evolution of planetary systems. The consistent relationship between orbital periods and radii across different planets in a system supports the idea of a common formation mechanism.","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Let's consider two examples: the Moon orbiting the Earth and the Earth orbiting the Sun. The Moon Orbiting the Earth: Orbital Period of the Moon ( \\(T_{\\text{Moon}}\\) ): \\(\\approx 27.3 \\text{ days} \\approx 27.3 \\times 24 \\times 3600 \\text{ seconds} \\approx 2.36 \\times 10^6 \\text{ s}\\) Average orbital radius of the Moon ( \\(r_{\\text{Moon}}\\) ): \\(\\approx 384,400 \\text{ km} \\approx 3.844 \\times 10^8 \\text{ m}\\) Mass of the Earth ( \\(M_{\\text{Earth}}\\) ): \\(\\approx 5.972 \\times 10^{24} \\text{ kg}\\) Gravitational constant ( \\(G\\) ): \\(\\approx 6.674 \\times 10^{-11} \\text{ N}\\cdot\\text{m}^2/\\text{kg}^2\\) Let's verify Kepler's Third Law using these values. Calculate \\(\\frac{4\\pi^2 r^3_{\\text{Moon}}}{GM_{\\text{Earth}}}\\) : \\[\\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})} \\approx \\frac{4 \\times (3.14159)^2 \\times 5.66 \\times 10^{25}}{3.985 \\times 10^{14}} \\approx 5.62 \\times 10^{12} \\text{ s}^2\\] Now, let's calculate \\(T^2_{\\text{Moon}}\\) : \\[(2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12} \\text{ s}^2\\] The calculated value from Kepler's Third Law is very close to the square of the Moon's orbital period, confirming the law. The Earth Orbiting the Sun: Orbital Period of the Earth ( \\(T_{\\text{Earth}}\\) ): \\(\\approx 365.25 \\text{ days} \\approx 365.25 \\times 24 \\times 3600 \\text{ seconds} \\approx 3.156 \\times 10^7 \\text{ s}\\) Average orbital radius of the Earth ( \\(r_{\\text{Earth}}\\) ): \\(\\approx 1.496 \\times 10^{11} \\text{ m}\\) Mass of the Sun ( \\(M_{\\text{Sun}}\\) ): \\(\\approx 1.989 \\times 10^{30} \\text{ kg}\\) Calculate \\(\\frac{4\\pi^2 r^3_{\\text{Earth}}}{GM_{\\text{Sun}}}\\) : \\[\\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.674 \\times 10^{-11})(1.989 \\times 10^{30})} \\approx \\frac{4 \\times (3.14159)^2 \\times 3.348 \\times 10^{33}}{1.327 \\times 10^{20}} \\approx 1.00 \\times 10^{15} \\text{ s}^2\\] Now, let's calculate \\(T^2_{\\text{Earth}}\\) : \\[(3.156 \\times 10^7)^2 \\approx 9.96 \\times 10^{14} \\text{ s}^2\\] Again, the calculated value is very close to the square of the Earth's orbital period, validating Kepler's Third Law.","title":"3. Real-world Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-model","text":"We can create a simplified computational model using Python to simulate circular orbits and observe the relationship between orbital period and radius. Below is an example Python script: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (N\u00b7m\u00b2/kg\u00b2) M = 1.989 * 10**30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(r): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Radii for the curve radii = np.linspace(1e10, 5e12, 100) # in meters T_squared = (orbital_period(radii))**2 r_cubed = radii**3 # Planetary data (semi-major axis in meters, orbital period in seconds) planets = { \"Mercury\": (5.79e10, 7.6e6), \"Venus\": (1.082e11, 1.94e7), \"Earth\": (1.496e11, 3.156e7), \"Mars\": (2.279e11, 5.93e7), \"Jupiter\": (7.785e11, 3.74e8) } # Prepare planet data for plotting planet_r_cubed = [r**3 for r, T in planets.values()] planet_T_squared = [T**2 for r, T in planets.values()] # Plot T^2 vs r^3 on a log-log scale plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=\"T\u00b2 vs r\u00b3 (Kepler's Law)\", color='blue') plt.scatter(planet_r_cubed, planet_T_squared, color='red', s=50, label=\"Planets\", zorder=5) # Add planet labels for name, (r, T) in planets.items(): plt.text(r**3, T**2, name, fontsize=9, ha='right') plt.xscale('log') plt.yscale('log') plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True, which='both', ls='--') plt.legend() plt.tight_layout() plt.show() This plot demonstrates the linear relationship between the square of the orbital period and the cube of the orbital radius, visually confirming Kepler's Third Law. The slope of the linear fit is proportional to \\(1/(GM)\\) . The Python code calculates and plots the relationship between the radius and the period, and also plots the square of the period against the cube of the radius to demonstrate the linear relationship predicted by Kepler's Third Law. The linear fit to the \\(T^2\\) vs \\(r^3\\) plot will have a slope equal to \\(\\frac{4\\pi^2}{GM}\\) .","title":"4. Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-to-elliptical-orbits","text":"For elliptical orbits, Kepler's Third Law still holds, but the radius \\(r\\) is replaced by the semi-major axis \\(a\\) of the ellipse. The semi-major axis is half of the longest diameter of the ellipse and is the average of the perihelion (closest approach) and aphelion (farthest distance) distances. The law can be written as: \\[T^2 = \\frac{4\\pi^2 a^3}{GM}\\] where \\(a\\) is the length of the semi-major axis. This extension is crucial for understanding the orbits of planets, comets, and many other celestial bodies that do not follow perfectly circular paths. The derivation for elliptical orbits involves more advanced mathematics and takes into account the varying speed of the orbiting object as it moves along its elliptical path, as described by Kepler's Second Law (the law of equal areas).","title":"5. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Introduction The concept of escape velocity is fundamental in astrophysics and space exploration. It defines the minimum speed required for an object to break free from a celestial body's gravitational pull. Expanding on this, cosmic velocities extend this concept to define the speeds required for orbiting, escaping, and leaving a star system. This document will define and analyze these velocities, provide mathematical derivations, and discuss their importance in space exploration. Definitions First Cosmic Velocity (Orbital Velocity): This is the minimum velocity required for an object to maintain a stable circular orbit around a celestial body, neglecting atmospheric drag. It is the velocity at which the centrifugal force balances the gravitational force. Second Cosmic Velocity (Escape Velocity): This is the minimum velocity required for an object to escape the gravitational influence of a celestial body and never return. It is the velocity at which the object's kinetic energy equals the magnitude of its gravitational potential energy. Third Cosmic Velocity (Solar Escape Velocity): This is the minimum velocity required for an object to escape the solar system from Earth's orbit. It accounts for the combined gravitational influence of Earth and the Sun. Mathematical Derivations First Cosmic Velocity ( \\(v_1\\) ) For a stable circular orbit, the gravitational force equals the centripetal force: \\[\\frac{GMm}{r^2} = \\frac{mv_1^2}{r}\\] Where: \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\text{ N m}^2/\\text{kg}^2\\) ) \\(M\\) is the mass of the celestial body \\(m\\) is the mass of the orbiting object \\(r\\) is the radius of the orbit (approximated as the radius of the celestial body for orbits close to the surface) Solving for \\(v_1\\) : \\[v_1 = \\sqrt{\\frac{GM}{r}}\\] Second Cosmic Velocity ( \\(v_2\\) ) The kinetic energy of the object must equal the gravitational potential energy: \\[\\frac{1}{2}mv_2^2 = \\frac{GMm}{r}\\] Solving for \\(v_2\\) : \\[v_2 = \\sqrt{\\frac{2GM}{r}}\\] Thus, \\(v_2 = \\sqrt{2}v_1\\) . Third Cosmic Velocity ( \\(v_3\\) ) To calculate the third cosmic velocity, we consider the object's initial velocity (Earth's orbital velocity) and the additional velocity needed to escape the Sun's gravitational pull. Earth's Orbital Velocity ( \\(v_{\\text{Earth}}\\) ): This is the first cosmic velocity with respect to the Sun at Earth's orbital radius. Solar Escape Velocity at Earth's Orbit ( \\(v_{\\text{Solar Escape}}\\) ): This is the second cosmic velocity with respect to the Sun at Earth's orbital radius. Third Cosmic Velocity ( \\(v_3\\) ): To calculate the third cosmic velocity (escape from the Solar System starting at Earth's surface), we account for: Escaping Earth's gravity - requiring Earth's second cosmic velocity \\(v_2\\) . Reaching solar escape velocity at Earth's orbital radius ( \\(v_{\\text{Solar Escape}}\\) ). Compensating for the orbital velocity of Earth around the Sun ( \\(v_{\\text{Earth Orbital}}\\) ), which assists or hinders depending on direction. Simplified Calculation: \\[v_3 = \\sqrt{v_{\\text{SolarEscape}}^2 + (v_2 - v_{\\text{EarthOrbital}})^2}\\] This expression assumes the spacecraft launches in the same direction as Earth's orbital motion. The \\((v_2 - v_{\\text{EarthOrbital}})\\) term reflects the adjustment needed after escaping Earth to reach the solar escape velocity. Alternatively, if launching directly from Earth's orbit, a more direct delta-v estimate is: \\[\\Delta v = v_{\\text{SolarEscape}} - v_{\\text{EarthOrbital}}\\] \ud83c\udf0d Parameters Used Celestial Body Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Moon \\(7.342 \\times 10^{22}\\) \\(1.7371 \\times 10^6\\) Mars \\(6.39 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\) Phyton \u0130mplemation import math import matplotlib.pyplot as plt import pandas as pd def calculate_cosmic_velocities(mass, radius, solar_mass=1.989e30, earth_orbital_radius=1.496e11): G = 6.674e-11 v1 = math.sqrt((G * mass) / radius) v2 = math.sqrt((2 * G * mass) / radius) earth_orbital_velocity = math.sqrt((G * solar_mass) / earth_orbital_radius) solar_escape_velocity = math.sqrt((2 * G * solar_mass) / earth_orbital_radius) # Simplified version: escape Earth and reach solar escape from Earth's orbit v3 = math.sqrt(solar_escape_velocity**2 + (v2 - earth_orbital_velocity)**2) return v1, v2, v3 # Add Moon to celestial bodies celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Moon\": {\"mass\": 7.342e22, \"radius\": 1.7371e6}, \"Mars\": {\"mass\": 6.39e23, \"radius\": 3.390e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7}, } velocities = {} for body, data in celestial_bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data[\"mass\"], data[\"radius\"]) velocities[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} print(\"Cosmic Velocities (in m/s):\") for body, v in velocities.items(): print(f\"{body}:\") print(f\" v1 (Orbital): {v['v1']:.2f} m/s\") print(f\" v2 (Escape): {v['v2']:.2f} m/s\") print(f\" v3 (Solar Escape): {v['v3']:.2f} m/s\") # Tabular display df = pd.DataFrame(velocities).T df.columns = [\"v1 (Orbital)\", \"v2 (Escape)\", \"v3 (Solar Escape)\"] df_kms = df.applymap(lambda x: f\"{x/1000:.2f} km/s\") print(\"\\nCosmic Velocities Table (in km/s):\") print(df_kms) # Visualization bodies = list(velocities.keys()) v1_values = [velocities[body][\"v1\"] for body in bodies] v2_values = [velocities[body][\"v2\"] for body in bodies] v3_values = [velocities[body][\"v3\"] for body in bodies] plt.figure(figsize=(10, 6)) plt.plot(bodies, v1_values, marker='o', linestyle='--', label='First Cosmic Velocity (v1)') plt.plot(bodies, v2_values, marker='o', linestyle='--', label='Second Cosmic Velocity (v2)') plt.plot(bodies, v3_values, marker='o', linestyle='--', label='Third Cosmic Velocity (v3)') plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (m/s)\") plt.title(\"Cosmic Velocities of Celestial Bodies\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() \ud83d\udcca Results (Velocities in km/s) Body \\(v_1\\) (Orbital) \\(v_2\\) (Escape) \\(v_3\\) (Solar Escape) Earth 7.91 km/s 11.18 km/s 16.65 km/s Moon 1.68 km/s 2.38 km/s 15.90 km/s Mars 3.55 km/s 5.03 km/s 16.12 km/s Jupiter 42.09 km/s 59.55 km/s 64.16 km/s Missions to Other Planets: The second cosmic velocity is essential for escaping a planet's gravitational pull for interplanetary missions. Achieving this velocity allows spacecraft to break free from Earth's gravity and travel to other planets or celestial bodies. Interstellar Travel: The third cosmic velocity is a fundamental consideration for missions aiming to leave the solar system. It provides the necessary speed to overcome the Sun's gravitational influence and venture into interstellar space. Achieving These Velocities: Achieving these velocities requires significant energy, which drives the development of advanced propulsion systems. Innovations in rocket technology, fuel efficiency, and energy sources are critical to meeting these velocity requirements. Trajectory Planning: Understanding these velocities is critical for calculating trajectories, ensuring that spacecraft reach their destinations with minimal fuel consumption. Precise calculations are necessary to optimize mission efficiency and reduce costs. Asteroid Deflection: Calculating the escape velocity from asteroids is important for missions aiming to deflect or redirect them. Understanding the gravitational influence of asteroids helps in planning missions to mitigate potential threats to Earth.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The concept of escape velocity is fundamental in astrophysics and space exploration. It defines the minimum speed required for an object to break free from a celestial body's gravitational pull. Expanding on this, cosmic velocities extend this concept to define the speeds required for orbiting, escaping, and leaving a star system. This document will define and analyze these velocities, provide mathematical derivations, and discuss their importance in space exploration.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"First Cosmic Velocity (Orbital Velocity): This is the minimum velocity required for an object to maintain a stable circular orbit around a celestial body, neglecting atmospheric drag. It is the velocity at which the centrifugal force balances the gravitational force. Second Cosmic Velocity (Escape Velocity): This is the minimum velocity required for an object to escape the gravitational influence of a celestial body and never return. It is the velocity at which the object's kinetic energy equals the magnitude of its gravitational potential energy. Third Cosmic Velocity (Solar Escape Velocity): This is the minimum velocity required for an object to escape the solar system from Earth's orbit. It accounts for the combined gravitational influence of Earth and the Sun.","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"For a stable circular orbit, the gravitational force equals the centripetal force: \\[\\frac{GMm}{r^2} = \\frac{mv_1^2}{r}\\] Where: \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\text{ N m}^2/\\text{kg}^2\\) ) \\(M\\) is the mass of the celestial body \\(m\\) is the mass of the orbiting object \\(r\\) is the radius of the orbit (approximated as the radius of the celestial body for orbits close to the surface) Solving for \\(v_1\\) : \\[v_1 = \\sqrt{\\frac{GM}{r}}\\]","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"The kinetic energy of the object must equal the gravitational potential energy: \\[\\frac{1}{2}mv_2^2 = \\frac{GMm}{r}\\] Solving for \\(v_2\\) : \\[v_2 = \\sqrt{\\frac{2GM}{r}}\\] Thus, \\(v_2 = \\sqrt{2}v_1\\) .","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"To calculate the third cosmic velocity, we consider the object's initial velocity (Earth's orbital velocity) and the additional velocity needed to escape the Sun's gravitational pull. Earth's Orbital Velocity ( \\(v_{\\text{Earth}}\\) ): This is the first cosmic velocity with respect to the Sun at Earth's orbital radius. Solar Escape Velocity at Earth's Orbit ( \\(v_{\\text{Solar Escape}}\\) ): This is the second cosmic velocity with respect to the Sun at Earth's orbital radius. Third Cosmic Velocity ( \\(v_3\\) ): To calculate the third cosmic velocity (escape from the Solar System starting at Earth's surface), we account for: Escaping Earth's gravity - requiring Earth's second cosmic velocity \\(v_2\\) . Reaching solar escape velocity at Earth's orbital radius ( \\(v_{\\text{Solar Escape}}\\) ). Compensating for the orbital velocity of Earth around the Sun ( \\(v_{\\text{Earth Orbital}}\\) ), which assists or hinders depending on direction. Simplified Calculation: \\[v_3 = \\sqrt{v_{\\text{SolarEscape}}^2 + (v_2 - v_{\\text{EarthOrbital}})^2}\\] This expression assumes the spacecraft launches in the same direction as Earth's orbital motion. The \\((v_2 - v_{\\text{EarthOrbital}})\\) term reflects the adjustment needed after escaping Earth to reach the solar escape velocity. Alternatively, if launching directly from Earth's orbit, a more direct delta-v estimate is: \\[\\Delta v = v_{\\text{SolarEscape}} - v_{\\text{EarthOrbital}}\\]","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-used","text":"Celestial Body Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Moon \\(7.342 \\times 10^{22}\\) \\(1.7371 \\times 10^6\\) Mars \\(6.39 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\)","title":"\ud83c\udf0d Parameters Used"},{"location":"1%20Physics/2%20Gravity/Problem_2/#phyton-implemation","text":"import math import matplotlib.pyplot as plt import pandas as pd def calculate_cosmic_velocities(mass, radius, solar_mass=1.989e30, earth_orbital_radius=1.496e11): G = 6.674e-11 v1 = math.sqrt((G * mass) / radius) v2 = math.sqrt((2 * G * mass) / radius) earth_orbital_velocity = math.sqrt((G * solar_mass) / earth_orbital_radius) solar_escape_velocity = math.sqrt((2 * G * solar_mass) / earth_orbital_radius) # Simplified version: escape Earth and reach solar escape from Earth's orbit v3 = math.sqrt(solar_escape_velocity**2 + (v2 - earth_orbital_velocity)**2) return v1, v2, v3 # Add Moon to celestial bodies celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Moon\": {\"mass\": 7.342e22, \"radius\": 1.7371e6}, \"Mars\": {\"mass\": 6.39e23, \"radius\": 3.390e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7}, } velocities = {} for body, data in celestial_bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data[\"mass\"], data[\"radius\"]) velocities[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} print(\"Cosmic Velocities (in m/s):\") for body, v in velocities.items(): print(f\"{body}:\") print(f\" v1 (Orbital): {v['v1']:.2f} m/s\") print(f\" v2 (Escape): {v['v2']:.2f} m/s\") print(f\" v3 (Solar Escape): {v['v3']:.2f} m/s\") # Tabular display df = pd.DataFrame(velocities).T df.columns = [\"v1 (Orbital)\", \"v2 (Escape)\", \"v3 (Solar Escape)\"] df_kms = df.applymap(lambda x: f\"{x/1000:.2f} km/s\") print(\"\\nCosmic Velocities Table (in km/s):\") print(df_kms) # Visualization bodies = list(velocities.keys()) v1_values = [velocities[body][\"v1\"] for body in bodies] v2_values = [velocities[body][\"v2\"] for body in bodies] v3_values = [velocities[body][\"v3\"] for body in bodies] plt.figure(figsize=(10, 6)) plt.plot(bodies, v1_values, marker='o', linestyle='--', label='First Cosmic Velocity (v1)') plt.plot(bodies, v2_values, marker='o', linestyle='--', label='Second Cosmic Velocity (v2)') plt.plot(bodies, v3_values, marker='o', linestyle='--', label='Third Cosmic Velocity (v3)') plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (m/s)\") plt.title(\"Cosmic Velocities of Celestial Bodies\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Phyton \u0130mplemation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#results-velocities-in-kms","text":"Body \\(v_1\\) (Orbital) \\(v_2\\) (Escape) \\(v_3\\) (Solar Escape) Earth 7.91 km/s 11.18 km/s 16.65 km/s Moon 1.68 km/s 2.38 km/s 15.90 km/s Mars 3.55 km/s 5.03 km/s 16.12 km/s Jupiter 42.09 km/s 59.55 km/s 64.16 km/s","title":"\ud83d\udcca Results (Velocities in km/s)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#missions-to-other-planets","text":"The second cosmic velocity is essential for escaping a planet's gravitational pull for interplanetary missions. Achieving this velocity allows spacecraft to break free from Earth's gravity and travel to other planets or celestial bodies.","title":"Missions to Other Planets:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#interstellar-travel","text":"The third cosmic velocity is a fundamental consideration for missions aiming to leave the solar system. It provides the necessary speed to overcome the Sun's gravitational influence and venture into interstellar space.","title":"Interstellar Travel:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#achieving-these-velocities","text":"Achieving these velocities requires significant energy, which drives the development of advanced propulsion systems. Innovations in rocket technology, fuel efficiency, and energy sources are critical to meeting these velocity requirements.","title":"Achieving These Velocities:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#trajectory-planning","text":"Understanding these velocities is critical for calculating trajectories, ensuring that spacecraft reach their destinations with minimal fuel consumption. Precise calculations are necessary to optimize mission efficiency and reduce costs.","title":"Trajectory Planning:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#asteroid-deflection","text":"Calculating the escape velocity from asteroids is important for missions aiming to deflect or redirect them. Understanding the gravitational influence of asteroids helps in planning missions to mitigate potential threats to Earth.","title":"Asteroid Deflection:"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Introduction Understanding the motion of objects under the influence of Earth's gravity is fundamental to space exploration. When a payload is released from a moving rocket near Earth, its subsequent trajectory is governed by its initial conditions (position and velocity at the time of release) and the gravitational force exerted by Earth. This problem explores the different types of trajectories possible and provides a computational tool to simulate and visualize these paths. Theoretical Background The motion of the payload is primarily governed by Newton's Law of Universal Gravitation , which states that every particle in the universe attracts every other particle with a force that is directly proportional to the product of their masses and inversely proportional to the square of the distance between their centers. Mathematically, the force \\(F\\) exerted by Earth (mass \\(M\\) ) on the payload (mass \\(m\\) ) is given by: \\[F = -G \\frac{Mm}{r^2} \\hat{r}\\] where: * \\(G\\) is the universal gravitational constant ( \\(6.674 \\times 10^{-11} \\text{ N} \\cdot \\text{m}^2/\\text{kg}^2\\) ), * \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\text{ kg}\\) ), * \\(m\\) is the mass of the payload, * \\(r\\) is the distance between the center of Earth and the payload, * \\(\\hat{r}\\) is the unit vector pointing from the center of Earth to the payload. From Newton's second law of motion ( \\(F = ma\\) ), the acceleration \\(a\\) of the payload is: \\[a = \\frac{F}{m} = -G \\frac{M}{r^2} \\hat{r}\\] This acceleration is always directed towards the center of Earth. Types of Trajectories The type of trajectory the payload will follow depends on its total mechanical energy , which is the sum of its kinetic energy ( \\(K\\) ) and potential energy ( \\(U\\) ). The gravitational potential energy of the payload at a distance \\(r\\) from the center of Earth is: \\[U = -G \\frac{Mm}{r}\\] The kinetic energy of the payload with velocity \\(v\\) is: \\[K = \\frac{1}{2}mv^2\\] The total energy \\(E\\) is: \\[E = K + U = \\frac{1}{2}mv^2 - G \\frac{Mm}{r}\\] The shape of the trajectory is determined by the sign of the total energy: Elliptical Trajectory ( \\(E < 0\\) ) : If the total energy is negative, the payload is bound to Earth and will follow an elliptical orbit. A circle is a special case of an ellipse where the eccentricity is zero. This is typical for payloads that are intended to orbit Earth. Parabolic Trajectory ( \\(E = 0\\) ) : If the total energy is exactly zero, the payload will follow a parabolic trajectory. This is the minimum energy required for the payload to escape Earth's gravitational pull and never return. The velocity at which this occurs at a given distance \\(r\\) is the escape velocity : \\( \\(v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}}\\) \\) Hyperbolic Trajectory ( \\(E > 0\\) ) : If the total energy is positive, the payload has more than enough energy to escape Earth's gravity and will follow a hyperbolic trajectory. Numerical Simulation To simulate the motion of the payload, we can use numerical methods to solve the equations of motion. We will use a simple Euler method for this demonstration, but more accurate methods like the Runge-Kutta method can be used for higher precision. Let \\(\\mathbf{r} = (x, y)\\) be the position vector of the payload and \\(\\mathbf{v} = (v_x, v_y)\\) be its velocity vector in a 2D plane (we can extend this to 3D if needed). The acceleration vector \\(\\mathbf{a} = (a_x, a_y)\\) is given by: \\[a_x = -GM \\frac{x}{(x^2 + y^2)^{3/2}}$$ $$a_y = -GM \\frac{y}{(x^2 + y^2)^{3/2}}\\] The Euler method updates the position and velocity at each time step \\(\\Delta t\\) as follows: \\[\\mathbf{v}_{i+1} = \\mathbf{v}_i + \\mathbf{a}_i \\Delta t$$ $$\\mathbf{r}_{i+1} = \\mathbf{r}_i + \\mathbf{v}_i \\Delta t\\] The code has been extended to simulate the trajectories of a payload released from an altitude of 800 km above Earth's surface. We are now investigating multiple launch velocities ranging from 5 km/s to 13 km/s (with 0.5 km/s increments). Each trajectory is computed using the Euler method to numerically solve the equations of motion under Earth's gravitational force. Simulation and Plotting We simulate the trajectories for various initial velocities, starting each payload at a position 800 km above Earth, placed on the right side of Earth (positive x-axis). The velocities tested include: 5.0 km/s 5.5 km/s 6.0 km/s ... 13.0 km/s Each velocity represents a different scenario for the payload's trajectory, which could be elliptical (orbit), escape, or reentry based on the initial conditions. The Earth is drawn to scale in the plot as a blue circle, and the trajectories are displayed accordingly. Re-entry Trajectories : For velocities below the orbital velocity of Earth at this altitude. Elliptical Trajectories : For velocities near the orbital velocity of Earth at this altitude. Escape Trajectories : For velocities greater than the escape velocity of Earth at the given altitude. The simulation also now visually shows the Earth in the plot for context. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Earth mass (kg) R_earth = 6371e3 # Earth radius (m) # Initial conditions altitude = 800e3 initial_distance = R_earth + altitude initial_position = [initial_distance, 0] # on the right side # Velocity range (in m/s) velocities_kms = np.arange(5.0, 13.5, 0.5) velocities = velocities_kms * 1e3 # Time parameters dt = 1 # time step (s) time_steps = 20000 # Containers for categorized results crashes = [] orbits = [] escapes = [] def simulate_trajectory(position, velocity, steps, dt): pos = np.array(position, dtype=float) vel = np.array(velocity, dtype=float) traj = [pos.copy()] for _ in range(steps): r = np.linalg.norm(pos) if r <= R_earth: return np.array(traj), \"crash\" if r > 10 * initial_distance: return np.array(traj), \"escape\" acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt traj.append(pos.copy()) return np.array(traj), \"orbit\" # Simulate all velocities for v in velocities: v0 = [0, v] traj, kind = simulate_trajectory(initial_position, v0, time_steps, dt) if kind == \"crash\": crashes.append((v, traj)) elif kind == \"orbit\": orbits.append((v, traj)) elif kind == \"escape\": escapes.append((v, traj)) # --- Plot Crash Cases (Zoomed In) --- plt.figure(figsize=(8, 8)) for v, traj in crashes: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Trajectories that Crash into Earth\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-1e7, 1.5e7) plt.ylim(-1e7, 1.5e7) plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Plot Orbital Cases (Zoomed Out) --- plt.figure(figsize=(8, 8)) for v, traj in orbits: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Orbital Trajectories\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-5e7, 5e7) plt.ylim(-5e7, 5e7) plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Plot Escape Cases (Zoomed Out More) --- plt.figure(figsize=(8, 8)) for v, traj in escapes: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Trajectories that Escape Earth\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-8e7, 1e8) plt.ylim(-8e7, 1e8) plt.grid(True) plt.legend() plt.tight_layout() plt.show() Analysis and Discussion The simulation demonstrates different types of trajectories based on the initial velocity of the payload. Reentry: A reentry trajectory is one where the payload is directed back towards Earth's atmosphere. This occurs when the payload's velocity is lower than the orbital velocity at its altitude, causing it to lose altitude over time due to gravity. The \"Crash into Earth\" case illustrates this, where the payload's elliptical orbit intersects with Earth. Orbital Insertion: For a payload to be inserted into a stable orbit around Earth, its initial velocity at a certain altitude must be carefully chosen. The velocity should be high enough to counteract gravity and prevent the payload from falling back to Earth, but not so high that it escapes Earth's gravitational pull. The simulation with \"Orbital trajectories\" shows an elliptical trajectory, which, with fine-tuning of the initial velocity, could become a circular orbit. Orbital insertion typically involves achieving a specific velocity vector at a desired altitude. Escape: An escape trajectory is achieved when the payload's initial velocity is equal to or greater than the escape velocity at its initial position. In this case, the payload will have enough kinetic energy to overcome Earth's gravitational potential energy and move away from Earth indefinitely (following a parabolic or hyperbolic path). The \"Escape Earth\" simulation shows the payload moving away from Earth. Further Considerations and Improvements More Accurate Numerical Methods: The Euler method is simple but can be inaccurate for long simulations or large time steps. Using methods like the Runge-Kutta 4th order method would provide more accurate results. 3D Simulation: For more realistic scenarios, the simulation should be extended to three dimensions. Atmospheric Drag: In the lower altitudes, atmospheric drag plays a significant role in the trajectory of a payload, causing it to slow down and eventually burn up or land. This effect is not included in the current simulation. Perturbations: The gravitational forces of other celestial bodies (like the Moon and the Sun) can also affect the payload's trajectory over long periods. These perturbations are not considered here. Visualization: More sophisticated visualization tools can be used to create animations of the payload's motion.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#introduction","text":"Understanding the motion of objects under the influence of Earth's gravity is fundamental to space exploration. When a payload is released from a moving rocket near Earth, its subsequent trajectory is governed by its initial conditions (position and velocity at the time of release) and the gravitational force exerted by Earth. This problem explores the different types of trajectories possible and provides a computational tool to simulate and visualize these paths.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"The motion of the payload is primarily governed by Newton's Law of Universal Gravitation , which states that every particle in the universe attracts every other particle with a force that is directly proportional to the product of their masses and inversely proportional to the square of the distance between their centers. Mathematically, the force \\(F\\) exerted by Earth (mass \\(M\\) ) on the payload (mass \\(m\\) ) is given by: \\[F = -G \\frac{Mm}{r^2} \\hat{r}\\] where: * \\(G\\) is the universal gravitational constant ( \\(6.674 \\times 10^{-11} \\text{ N} \\cdot \\text{m}^2/\\text{kg}^2\\) ), * \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\text{ kg}\\) ), * \\(m\\) is the mass of the payload, * \\(r\\) is the distance between the center of Earth and the payload, * \\(\\hat{r}\\) is the unit vector pointing from the center of Earth to the payload. From Newton's second law of motion ( \\(F = ma\\) ), the acceleration \\(a\\) of the payload is: \\[a = \\frac{F}{m} = -G \\frac{M}{r^2} \\hat{r}\\] This acceleration is always directed towards the center of Earth.","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"The type of trajectory the payload will follow depends on its total mechanical energy , which is the sum of its kinetic energy ( \\(K\\) ) and potential energy ( \\(U\\) ). The gravitational potential energy of the payload at a distance \\(r\\) from the center of Earth is: \\[U = -G \\frac{Mm}{r}\\] The kinetic energy of the payload with velocity \\(v\\) is: \\[K = \\frac{1}{2}mv^2\\] The total energy \\(E\\) is: \\[E = K + U = \\frac{1}{2}mv^2 - G \\frac{Mm}{r}\\] The shape of the trajectory is determined by the sign of the total energy: Elliptical Trajectory ( \\(E < 0\\) ) : If the total energy is negative, the payload is bound to Earth and will follow an elliptical orbit. A circle is a special case of an ellipse where the eccentricity is zero. This is typical for payloads that are intended to orbit Earth. Parabolic Trajectory ( \\(E = 0\\) ) : If the total energy is exactly zero, the payload will follow a parabolic trajectory. This is the minimum energy required for the payload to escape Earth's gravitational pull and never return. The velocity at which this occurs at a given distance \\(r\\) is the escape velocity : \\( \\(v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}}\\) \\) Hyperbolic Trajectory ( \\(E > 0\\) ) : If the total energy is positive, the payload has more than enough energy to escape Earth's gravity and will follow a hyperbolic trajectory.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"To simulate the motion of the payload, we can use numerical methods to solve the equations of motion. We will use a simple Euler method for this demonstration, but more accurate methods like the Runge-Kutta method can be used for higher precision. Let \\(\\mathbf{r} = (x, y)\\) be the position vector of the payload and \\(\\mathbf{v} = (v_x, v_y)\\) be its velocity vector in a 2D plane (we can extend this to 3D if needed). The acceleration vector \\(\\mathbf{a} = (a_x, a_y)\\) is given by: \\[a_x = -GM \\frac{x}{(x^2 + y^2)^{3/2}}$$ $$a_y = -GM \\frac{y}{(x^2 + y^2)^{3/2}}\\] The Euler method updates the position and velocity at each time step \\(\\Delta t\\) as follows: \\[\\mathbf{v}_{i+1} = \\mathbf{v}_i + \\mathbf{a}_i \\Delta t$$ $$\\mathbf{r}_{i+1} = \\mathbf{r}_i + \\mathbf{v}_i \\Delta t\\] The code has been extended to simulate the trajectories of a payload released from an altitude of 800 km above Earth's surface. We are now investigating multiple launch velocities ranging from 5 km/s to 13 km/s (with 0.5 km/s increments). Each trajectory is computed using the Euler method to numerically solve the equations of motion under Earth's gravitational force.","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-and-plotting","text":"We simulate the trajectories for various initial velocities, starting each payload at a position 800 km above Earth, placed on the right side of Earth (positive x-axis). The velocities tested include: 5.0 km/s 5.5 km/s 6.0 km/s ... 13.0 km/s Each velocity represents a different scenario for the payload's trajectory, which could be elliptical (orbit), escape, or reentry based on the initial conditions. The Earth is drawn to scale in the plot as a blue circle, and the trajectories are displayed accordingly. Re-entry Trajectories : For velocities below the orbital velocity of Earth at this altitude. Elliptical Trajectories : For velocities near the orbital velocity of Earth at this altitude. Escape Trajectories : For velocities greater than the escape velocity of Earth at the given altitude. The simulation also now visually shows the Earth in the plot for context. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Earth mass (kg) R_earth = 6371e3 # Earth radius (m) # Initial conditions altitude = 800e3 initial_distance = R_earth + altitude initial_position = [initial_distance, 0] # on the right side # Velocity range (in m/s) velocities_kms = np.arange(5.0, 13.5, 0.5) velocities = velocities_kms * 1e3 # Time parameters dt = 1 # time step (s) time_steps = 20000 # Containers for categorized results crashes = [] orbits = [] escapes = [] def simulate_trajectory(position, velocity, steps, dt): pos = np.array(position, dtype=float) vel = np.array(velocity, dtype=float) traj = [pos.copy()] for _ in range(steps): r = np.linalg.norm(pos) if r <= R_earth: return np.array(traj), \"crash\" if r > 10 * initial_distance: return np.array(traj), \"escape\" acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt traj.append(pos.copy()) return np.array(traj), \"orbit\" # Simulate all velocities for v in velocities: v0 = [0, v] traj, kind = simulate_trajectory(initial_position, v0, time_steps, dt) if kind == \"crash\": crashes.append((v, traj)) elif kind == \"orbit\": orbits.append((v, traj)) elif kind == \"escape\": escapes.append((v, traj)) # --- Plot Crash Cases (Zoomed In) --- plt.figure(figsize=(8, 8)) for v, traj in crashes: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Trajectories that Crash into Earth\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-1e7, 1.5e7) plt.ylim(-1e7, 1.5e7) plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Plot Orbital Cases (Zoomed Out) --- plt.figure(figsize=(8, 8)) for v, traj in orbits: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Orbital Trajectories\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-5e7, 5e7) plt.ylim(-5e7, 5e7) plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Plot Escape Cases (Zoomed Out More) --- plt.figure(figsize=(8, 8)) for v, traj in escapes: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Trajectories that Escape Earth\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-8e7, 1e8) plt.ylim(-8e7, 1e8) plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Simulation and Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/#analysis-and-discussion","text":"The simulation demonstrates different types of trajectories based on the initial velocity of the payload. Reentry: A reentry trajectory is one where the payload is directed back towards Earth's atmosphere. This occurs when the payload's velocity is lower than the orbital velocity at its altitude, causing it to lose altitude over time due to gravity. The \"Crash into Earth\" case illustrates this, where the payload's elliptical orbit intersects with Earth. Orbital Insertion: For a payload to be inserted into a stable orbit around Earth, its initial velocity at a certain altitude must be carefully chosen. The velocity should be high enough to counteract gravity and prevent the payload from falling back to Earth, but not so high that it escapes Earth's gravitational pull. The simulation with \"Orbital trajectories\" shows an elliptical trajectory, which, with fine-tuning of the initial velocity, could become a circular orbit. Orbital insertion typically involves achieving a specific velocity vector at a desired altitude. Escape: An escape trajectory is achieved when the payload's initial velocity is equal to or greater than the escape velocity at its initial position. In this case, the payload will have enough kinetic energy to overcome Earth's gravitational potential energy and move away from Earth indefinitely (following a parabolic or hyperbolic path). The \"Escape Earth\" simulation shows the payload moving away from Earth.","title":"Analysis and Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#further-considerations-and-improvements","text":"More Accurate Numerical Methods: The Euler method is simple but can be inaccurate for long simulations or large time steps. Using methods like the Runge-Kutta 4th order method would provide more accurate results. 3D Simulation: For more realistic scenarios, the simulation should be extended to three dimensions. Atmospheric Drag: In the lower altitudes, atmospheric drag plays a significant role in the trajectory of a payload, causing it to slow down and eventually burn up or land. This effect is not included in the current simulation. Perturbations: The gravitational forces of other celestial bodies (like the Moon and the Sun) can also affect the payload's trajectory over long periods. These perturbations are not considered here. Visualization: More sophisticated visualization tools can be used to create animations of the payload's motion.","title":"Further Considerations and Improvements"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is easy to observe when ripples from different points meet. These patterns reveal how waves combine \u2013 either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns helps us understand wave behavior in a visual and intuitive way. This task allows us to explore the effects of wave phase, coherence, and geometry. Task Description A circular wave emitted from a point source located at \\((x_0, y_0)\\) is modeled by the following equation: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) : Water surface displacement at point \\((x, y)\\) and time \\(t\\) - A : Wave amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (with \\(\\lambda\\) as wavelength) - \\(\\omega = 2\\pi f\\) : Angular frequency (with \\(f\\) as frequency) - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source - \\(\\phi\\) : Initial phase When multiple sources emit waves, we use the principle of superposition: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Python Simulation Code To simulate and visualize the interference patterns for various point source configurations, use the following Python code. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D import os import matplotlib.ticker from matplotlib.colors import LinearSegmentedColormap # --- Wave Parameters --- A = 1 # Amplitude wavelength = 2 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 # Phase # --- Coordinate Grid --- x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # --- Polygon Vertex Generator --- def polygon_vertices(n_sides, radius=4): return [ (radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides) ] # --- Wave from a Single Source --- def wave_source(x0, y0, t): R = np.sqrt((X - x0)**2 + (Y - y0)**2) R[R == 0] = 1e-6 # avoid division by zero return (A / R) * np.cos(k * R - omega * t + phi) # --- Superposition of Waves --- def superpose_sources(positions, t=0): Z = np.zeros_like(X) for (x0, y0) in positions: Z += wave_source(x0, y0, t) return Z # --- 3D Plotting Helper --- def plot_3d(Z, title, filename): fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Define custom colormap with smooth transitions colors = ['yellow', 'green', 'blue', 'purple', 'red'] cmap = LinearSegmentedColormap.from_list('custom_div', colors) # Plot the surface with the custom colormap surf = ax.plot_surface(X, Y, Z, cmap=cmap, edgecolor='none') ax.set_title(title) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') # Ensure symmetric Z-axis limits to clearly show negative displacement z_max = np.max(np.abs(Z)) ax.set_zlim(-z_max, z_max) # Set more frequent Z-axis ticks for precise information ax.zaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10)) # Adjust viewing angle for better visualization of troughs ax.view_init(elev=30, azim=-45) # Add a color bar to the side of the plot fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10, label='Displacement') plt.tight_layout() plt.savefig(filename) plt.show() # --- Static Visualizations (Now in 3D) --- plot_3d(superpose_sources([(0, 0)], t=0), \"One Source\", \"one_source_3d.png\") plot_3d(superpose_sources([(-3, 0), (3, 0)], t=0), \"Two Sources\", \"two_sources_3d.png\") plot_3d( superpose_sources(polygon_vertices(3)), \"Three Sources (Triangle)\", \"triangle_3d.png\", ) plot_3d( superpose_sources(polygon_vertices(5)), \"Five Sources (Pentagon)\", \"pentagon_3d.png\", ) # --- Optional: Animated GIF of Pentagon Interference (unchanged - difficult to map colors directly to values in a heatmap) --- def generate_gif(positions, filename=\"interference_pentagon.gif\", frames=60): fig, ax = plt.subplots(figsize=(6, 5)) im = ax.imshow( superpose_sources(positions, t=0), extent=(-10, 10, -10, 10), cmap='coolwarm', # Keep coolwarm for the animation. Custom colormaps are difficult with imshow. origin='lower', ) ax.set_title(\"Wave Interference Animation\") ax.set_xlabel('x') ax.set_ylabel('y') # Adding a colorbar for the 2D heatmap as well plt.colorbar(im, label='Displacement') def update(frame): Z = superpose_sources(positions, t=frame * 0.2) im.set_array(Z) return [im] ani = FuncAnimation(fig, update, frames=frames, interval=80, blit=True) ani.save(filename, writer='pillow') plt.close() generate_gif(polygon_vertices(5)) # Generates 'interference_pentagon.gif'","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is easy to observe when ripples from different points meet. These patterns reveal how waves combine \u2013 either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns helps us understand wave behavior in a visual and intuitive way. This task allows us to explore the effects of wave phase, coherence, and geometry.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-description","text":"A circular wave emitted from a point source located at \\((x_0, y_0)\\) is modeled by the following equation: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) : Water surface displacement at point \\((x, y)\\) and time \\(t\\) - A : Wave amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (with \\(\\lambda\\) as wavelength) - \\(\\omega = 2\\pi f\\) : Angular frequency (with \\(f\\) as frequency) - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source - \\(\\phi\\) : Initial phase When multiple sources emit waves, we use the principle of superposition: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\]","title":"Task Description"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"To simulate and visualize the interference patterns for various point source configurations, use the following Python code. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D import os import matplotlib.ticker from matplotlib.colors import LinearSegmentedColormap # --- Wave Parameters --- A = 1 # Amplitude wavelength = 2 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 # Phase # --- Coordinate Grid --- x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # --- Polygon Vertex Generator --- def polygon_vertices(n_sides, radius=4): return [ (radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides) ] # --- Wave from a Single Source --- def wave_source(x0, y0, t): R = np.sqrt((X - x0)**2 + (Y - y0)**2) R[R == 0] = 1e-6 # avoid division by zero return (A / R) * np.cos(k * R - omega * t + phi) # --- Superposition of Waves --- def superpose_sources(positions, t=0): Z = np.zeros_like(X) for (x0, y0) in positions: Z += wave_source(x0, y0, t) return Z # --- 3D Plotting Helper --- def plot_3d(Z, title, filename): fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Define custom colormap with smooth transitions colors = ['yellow', 'green', 'blue', 'purple', 'red'] cmap = LinearSegmentedColormap.from_list('custom_div', colors) # Plot the surface with the custom colormap surf = ax.plot_surface(X, Y, Z, cmap=cmap, edgecolor='none') ax.set_title(title) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') # Ensure symmetric Z-axis limits to clearly show negative displacement z_max = np.max(np.abs(Z)) ax.set_zlim(-z_max, z_max) # Set more frequent Z-axis ticks for precise information ax.zaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10)) # Adjust viewing angle for better visualization of troughs ax.view_init(elev=30, azim=-45) # Add a color bar to the side of the plot fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10, label='Displacement') plt.tight_layout() plt.savefig(filename) plt.show() # --- Static Visualizations (Now in 3D) --- plot_3d(superpose_sources([(0, 0)], t=0), \"One Source\", \"one_source_3d.png\") plot_3d(superpose_sources([(-3, 0), (3, 0)], t=0), \"Two Sources\", \"two_sources_3d.png\") plot_3d( superpose_sources(polygon_vertices(3)), \"Three Sources (Triangle)\", \"triangle_3d.png\", ) plot_3d( superpose_sources(polygon_vertices(5)), \"Five Sources (Pentagon)\", \"pentagon_3d.png\", ) # --- Optional: Animated GIF of Pentagon Interference (unchanged - difficult to map colors directly to values in a heatmap) --- def generate_gif(positions, filename=\"interference_pentagon.gif\", frames=60): fig, ax = plt.subplots(figsize=(6, 5)) im = ax.imshow( superpose_sources(positions, t=0), extent=(-10, 10, -10, 10), cmap='coolwarm', # Keep coolwarm for the animation. Custom colormaps are difficult with imshow. origin='lower', ) ax.set_title(\"Wave Interference Animation\") ax.set_xlabel('x') ax.set_ylabel('y') # Adding a colorbar for the 2D heatmap as well plt.colorbar(im, label='Displacement') def update(frame): Z = superpose_sources(positions, t=frame * 0.2) im.set_array(Z) return [im] ani = FuncAnimation(fig, update, frames=frames, interval=80, blit=True) ani.save(filename, writer='pillow') plt.close() generate_gif(polygon_vertices(5)) # Generates 'interference_pentagon.gif'","title":"Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force, expressed as: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] governs the motion of charged particles in electric and magnetic fields. This fundamental law is critical in applications ranging from plasma physics and particle accelerators to astrophysical phenomena. Through simulation, we can visualize and understand how particles move under the influence of these fields. 1. Exploration of Applications Particle Accelerators : Lorentz force is used to steer and accelerate particles. Mass Spectrometers : Charged particles are deflected by magnetic fields to determine mass-to-charge ratios. Fusion Devices (e.g., Tokamaks) : Magnetic confinement relies on controlled charged particle motion. Electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields are essential tools for manipulating charged particles in controlled environments. 2. Simulation Assumptions We use the following values for all simulations: Charge: \\( q = 1 \\, C \\) Mass: \\( m = 1\\,g = 0.001\\,kg \\) Time step: \\( \\Delta t = 0.01\\,s \\) Integration: Euler method 3. Simulating Trajectories Under Various Conditions A. Circular Motion in a Uniform Magnetic Field No electric field. Particle moves perpendicular to \\( \\vec{B} \\) . \\[ \\vec{F} = q\\vec{v} \\times \\vec{B} \\] Expected result: circular path import numpy as np import matplotlib.pyplot as plt q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 0.0]) dt = 1e-6 steps = 5000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) plt.plot(r_list[:, 0], r_list[:, 1]) plt.xlabel('x') plt.ylabel('y') plt.title('Circular trajectory (v \u22a5 B)') plt.axis('equal') plt.grid(True) plt.show() B. Spiral (Helical) Motion Along the Z-axis Introduce a velocity component along the magnetic field direction (z): \\[ \\vec{v}_0 = [0.0, -2.0, 2.0] \\] This leads to helical motion . import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 2.0]) dt = 1e-6 steps = 10000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(r_list[:, 0], r_list[:, 1], r_list[:, 2]) ax.set_title('Spiral along the z-axis') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') plt.show() C. Complex Trajectory in an Inclined Magnetic Field Using an inclined magnetic field and no electric field: \\(\\vec{B} = [0.2, 0.0, 1.0]\\) , \\(\\vec{E} = [0.0, 0.0, 0.0]\\) This setup results in a complex 3D spiral trajectory, due to the magnetic field having components in both the \\(x\\) and \\(z\\) directions. The particle spirals and drifts along an inclined axis. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 2.0]) dt = 1e-6 steps = 10000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(r_list[:, 0], r_list[:, 1], r_list[:, 2]) ax.set_title('Spiral along the z-axis') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') plt.show() 4. Parameter Exploration We explore how changes in the following affect particle trajectories: Electric and magnetic field strengths (| \\(\\vec{E}\\) |, | \\(\\vec{B}\\) |) Initial velocity \\(\\vec{v}_0\\) Charge \\(q\\) and mass \\(m\\) Key physical quantities: Larmor Radius: \\[ r_L = \\frac{m v_\\perp}{|qB|} \\] Cyclotron Frequency: \\[ \\omega_c = \\frac{|qB|}{m} \\] Drift Velocity in Crossed Fields: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] These determine whether the particle undergoes tight circular motion, slow spirals, or fast linear drifts. 5. Visualization Summary Scenarios Visualized: Circular motion in 2D under uniform \\(\\vec{B}\\) Spiral (helical) motion along \\(z\\) -axis with initial velocity component in \\(\\vec{B}\\) direction Complex drift/spiral motion under an inclined \\(\\vec{B}\\) field Each plot demonstrates how the Lorentz force shapes the trajectory based on the field configuration. 6. Discussion and Real-World Relevance These simulations relate to practical technologies: Cyclotrons: Acceleration through circular paths Magnetic Traps: Confinement using Lorentz force balancing Fusion Reactors: Plasma control via \\(\\vec{E}\\) and \\(\\vec{B}\\) shaping Mass Spectrometry: Field-dependent ion separation Understanding and simulating the Lorentz force enhances both theoretical insight and engineering capability.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] governs the motion of charged particles in electric and magnetic fields. This fundamental law is critical in applications ranging from plasma physics and particle accelerators to astrophysical phenomena. Through simulation, we can visualize and understand how particles move under the influence of these fields.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"Particle Accelerators : Lorentz force is used to steer and accelerate particles. Mass Spectrometers : Charged particles are deflected by magnetic fields to determine mass-to-charge ratios. Fusion Devices (e.g., Tokamaks) : Magnetic confinement relies on controlled charged particle motion. Electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields are essential tools for manipulating charged particles in controlled environments.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulation-assumptions","text":"We use the following values for all simulations: Charge: \\( q = 1 \\, C \\) Mass: \\( m = 1\\,g = 0.001\\,kg \\) Time step: \\( \\Delta t = 0.01\\,s \\) Integration: Euler method","title":"2. Simulation Assumptions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-simulating-trajectories-under-various-conditions","text":"","title":"3. Simulating Trajectories Under Various Conditions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#a-circular-motion-in-a-uniform-magnetic-field","text":"No electric field. Particle moves perpendicular to \\( \\vec{B} \\) . \\[ \\vec{F} = q\\vec{v} \\times \\vec{B} \\] Expected result: circular path import numpy as np import matplotlib.pyplot as plt q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 0.0]) dt = 1e-6 steps = 5000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) plt.plot(r_list[:, 0], r_list[:, 1]) plt.xlabel('x') plt.ylabel('y') plt.title('Circular trajectory (v \u22a5 B)') plt.axis('equal') plt.grid(True) plt.show()","title":"A. Circular Motion in a Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#b-spiral-helical-motion-along-the-z-axis","text":"Introduce a velocity component along the magnetic field direction (z): \\[ \\vec{v}_0 = [0.0, -2.0, 2.0] \\] This leads to helical motion . import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 2.0]) dt = 1e-6 steps = 10000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(r_list[:, 0], r_list[:, 1], r_list[:, 2]) ax.set_title('Spiral along the z-axis') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') plt.show()","title":"B. Spiral (Helical) Motion Along the Z-axis"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#c-complex-trajectory-in-an-inclined-magnetic-field","text":"Using an inclined magnetic field and no electric field: \\(\\vec{B} = [0.2, 0.0, 1.0]\\) , \\(\\vec{E} = [0.0, 0.0, 0.0]\\) This setup results in a complex 3D spiral trajectory, due to the magnetic field having components in both the \\(x\\) and \\(z\\) directions. The particle spirals and drifts along an inclined axis. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 2.0]) dt = 1e-6 steps = 10000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(r_list[:, 0], r_list[:, 1], r_list[:, 2]) ax.set_title('Spiral along the z-axis') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') plt.show()","title":"C. Complex Trajectory in an Inclined Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-parameter-exploration","text":"We explore how changes in the following affect particle trajectories: Electric and magnetic field strengths (| \\(\\vec{E}\\) |, | \\(\\vec{B}\\) |) Initial velocity \\(\\vec{v}_0\\) Charge \\(q\\) and mass \\(m\\)","title":"4. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-physical-quantities","text":"","title":"Key physical quantities:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#larmor-radius","text":"\\[ r_L = \\frac{m v_\\perp}{|qB|} \\]","title":"Larmor Radius:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#cyclotron-frequency","text":"\\[ \\omega_c = \\frac{|qB|}{m} \\]","title":"Cyclotron Frequency:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#drift-velocity-in-crossed-fields","text":"\\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] These determine whether the particle undergoes tight circular motion, slow spirals, or fast linear drifts.","title":"Drift Velocity in Crossed Fields:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-visualization-summary","text":"","title":"5. Visualization Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenarios-visualized","text":"Circular motion in 2D under uniform \\(\\vec{B}\\) Spiral (helical) motion along \\(z\\) -axis with initial velocity component in \\(\\vec{B}\\) direction Complex drift/spiral motion under an inclined \\(\\vec{B}\\) field Each plot demonstrates how the Lorentz force shapes the trajectory based on the field configuration.","title":"Scenarios Visualized:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-discussion-and-real-world-relevance","text":"These simulations relate to practical technologies: Cyclotrons: Acceleration through circular paths Magnetic Traps: Confinement using Lorentz force balancing Fusion Reactors: Plasma control via \\(\\vec{E}\\) and \\(\\vec{B}\\) shaping Mass Spectrometry: Field-dependent ion separation Understanding and simulating the Lorentz force enhances both theoretical insight and engineering capability.","title":"6. Discussion and Real-World Relevance"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Introduction and Motivation Calculating equivalent resistance is a fundamental task in circuit analysis. While traditional approaches use series and parallel simplification rules manually, graph theory provides a powerful alternative \u2013 transforming circuit analysis into an algorithmic graph simplification process. Circuits can be represented as graphs: - Nodes = junctions - Edges = resistors (with resistance as weight) By identifying series and parallel patterns in the graph, we can iteratively reduce it to compute total resistance between two terminals. This approach is: - Scalable for large networks - Automatable for software - Insightful for understanding electrical connectivity and topology Learning Goals After completing this task, you should be able to: Represent a resistor network as a weighted graph. Apply reduction rules (series and parallel) using graph algorithms. Implement an algorithm that simplifies arbitrary configurations. Analyze different circuit structures programmatically. Algorithm The circuit is modeled as a multigraph G = (V, E), where V is the set of junctions (nodes) and E is the set of resistors (edges). Each edge e \u2208 E has a weight r_e representing its resistance. Two distinct nodes, start_node and end_node , are specified as the terminals across which the equivalent resistance is sought. The algorithm proceeds as follows: Initialization: Construct the graph from the given circuit components. Validate that start_node and end_node exist in the graph. If start_node = end_node , the resistance is 0\u03a9. Iterative Reduction: Repeatedly apply the following reduction rules until no more simple series or parallel reductions are possible, or the graph is reduced to a single edge between start_node and end_node . Parallel Reduction: Identification: Find any pair of nodes (u, v) connected by two or more edges (resistors R\u2081, R\u2082, ..., R_k). Reduction: Replace these k parallel resistors with a single equivalent resistor R_p between u and v. The equivalent resistance is calculated as: ( R_p = (\u03a3\u1d62\u208c\u2081\u1d4f 1/R_i)\u207b\u00b9 ) if any R_i = 0, R_p = 0. If all R_i = \u221e, R_p = \u221e. Action: Remove the original k edges and add a new edge (u, v) with resistance R_p. If R_p = \u221e, effectively remove the connection unless it's the only path. After a reduction, restart the scan for further simplifications as the graph structure has changed. Series Reduction: Identification: Find any node w such that: w is not the start_node or end_node . The degree of w, deg(w), is exactly 2. Let the two edges incident to w be (u, w) with resistance R\u2081, and (w, v) with resistance R\u2082. Ensure u \u2260 v\u2081 (if u = v, it's a loop, not a simple series element in a path from start_node to end_node ). Reduction: Replace the two series resistors R\u2081 and R\u2082, and the intermediate node w with a single equivalent resistor R_s between u and v. The equivalent resistance is: ( R_s = R\u2081 + R\u2082 ) if R\u2081 = \u221e or R\u2082 = \u221e, then R_s = \u221e. Action: Remove node w (which also removes edges (u, w) and (w, v)). Add a new edge (u, v) with resistance R_s. If R_s = \u221e, effectively this path segment becomes an open circuit. After a reduction, restart the scan. Reduction: Replace these k parallel resistors with a single equivalent resistor R_p between u and v. The equivalent resistance is calculated as: ( R_p = (\u03a3\u1d62\u208c\u2081\u1d4f 1/R_i)\u207b\u00b9 ) if any R_i = 0, R_p = 0. If all R_i = \u221e, R_p = \u221e. Action: Remove the original k edges and add a new edge (u, v) with resistance R_p. If R_p = \u221e, effectively remove the connection unless it's the only path. After a reduction, restart the scan for further simplifications as the graph structure has changed. Action: Remove node w (which also removes edges (u, w) and (w, v)). Add a new edge (u, v) with resistance R_s. If R_s = \u221e, effectively this path segment becomes an open circuit. After a reduction, restart the scan. Termination and Result: The loop terminates if no series or parallel reductions were made in a full pass. Ideal Case: If the graph is reduced to a single edge between start_node and end_node , its resistance is the equivalent resistance. Final Parallel Case: If the graph consists of only start_node and end_node and multiple edges directly connecting them, these are in parallel. Calculate their combined parallel resistance. Non-Reducible Case: If the graph cannot be simplified further by these rules to one of the above states, the circuit may contain non-series-parallel configurations (e.g., a Wheatstone bridge not in balance). The algorithm, in this form, will report that it cannot fully reduce the circuit. Open Circuit: If, at any point or at the end, there is no path between start_node and end_node , the equivalent resistance is \u221e. Short Circuit: If an equivalent resistance of 0\u03a9 is found. Series Connection Two resistors R\u2081 and R\u2082 in series: R_eq = R\u2081 + R\u2082 Parallel Connection Two resistors R\u2081 and R\u2082 in parallel: 1/R_eq = 1/R\u2081 + 1/R\u2082 => R_eq = (1/R\u2081 + 1/R\u2082)\u207b\u00b9 Phyton \u0130mplemntaion from IPython import get_ipython from IPython.display import display import matplotlib.pyplot as plt import networkx as nx class ResistorNetworkAnalyzer: def __init__(self): self.step_count = 0 self.visualization_steps = [] def _get_edge_labels(self, G): \"\"\"Helper function to generate edge labels with resistance values\"\"\" edge_labels = {} for u, v, data in G.edges(data=True): if 'resistance' in data: # Handle MultiGraph key access here as well if isinstance(G, nx.MultiGraph) and len(G[u][v]) > 1: # If multiple edges, show all resistances labels = [f\"{d.get('resistance', 0):.2f}\u03a9\" for k, d in G[u][v].items()] edge_labels[(u, v)] = ', '.join(labels) else: edge_labels[(u, v)] = f\"{data['resistance']:.2f}\u03a9\" # Removed the redundant elif for MultiGraph, handled above return edge_labels def draw_circuit(self, G, pos, title, highlight_edges=None): \"\"\"Improved visualization function with better highlighting\"\"\" plt.figure(figsize=(10, 6)) # Node styling - T\u00fcm d\u00fc\u011f\u00fcmler k\u0131rm\u0131z\u0131 ve kare \u015feklinde node_colors = ['#FF0000' for node in G.nodes()] # T\u00fcm d\u00fc\u011f\u00fcmler i\u00e7in k\u0131rm\u0131z\u0131 renk nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=1800, node_shape='s', edgecolors='black', linewidths=2) # Kare \u015fekil nx.draw_networkx_labels(G, pos, font_size=14, font_weight='bold') # Draw all edges # Need to handle MultiGraph edges explicitly for drawing if isinstance(G, nx.MultiGraph): # Draw each edge individually for MultiGraphs for u, v, key, data in G.edges(keys=True, data=True): # Use connectionstyle to curve parallel edges for better visibility nx.draw_networkx_edges(G, pos, edgelist=[(u,v)], width=2, edge_color='black', connectionstyle='arc3,rad=0.1') else: nx.draw_networkx_edges(G, pos, width=2, edge_color='black') # Highlight edges that were modified if highlight_edges: # Need to handle MultiGraph highlighting carefully if isinstance(G, nx.MultiGraph): highlight_edges_with_keys = [] for u, v in highlight_edges: if G.has_edge(u, v): # Highlight all edges between u and v (assuming highlight_edges contains the pairs that were combined) # A more precise highlighting would require knowing the keys of the edges that were removed. # For visualization purposes, highlighting the path between nodes u and v is often sufficient. for key in G[u][v]: highlight_edges_with_keys.append((u, v, key)) if highlight_edges_with_keys: nx.draw_networkx_edges(G, pos, edgelist=highlight_edges_with_keys, edge_color='#FF5722', width=6, alpha=0.7, connectionstyle='arc3,rad=0.1') else: nx.draw_networkx_edges(G, pos, edgelist=highlight_edges, edge_color='#FF5722', width=6, alpha=0.7) # Edge labels with resistance values edge_labels = self._get_edge_labels(G) # nx.draw_networkx_edge_labels has issues with MultiGraph parallel edges. # It often labels only one of the parallel edges or overlaps labels. # A more advanced labeling for MultiGraphs might involve manually positioning labels. # For this example, we will keep the standard labeling, but be aware of limitations. nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=12, bbox=dict(facecolor='white', edgecolor='none', alpha=0.8, boxstyle='round,pad=0.3')) plt.title(title, fontsize=16, pad=20) plt.axis('off') plt.tight_layout() # Check if running in a Jupyter environment before trying to display ipython = get_ipython() if ipython is not None: display(plt.gcf()) # Use display for inline plotting in Jupyter else: plt.show() # Fallback for non-Jupyter environments plt.close() # Close the figure after showing to prevent memory issues def combine_series(self, G, pos): \"\"\"Combine series resistors with visualization\"\"\" changed = True while changed: changed = False for node in list(G.nodes): # Exclude terminal nodes and check degree # For MultiGraph, degree counts each edge if node not in (\"start\", \"end\", \"bas\", \"son\") and G.degree(node) == 2: neighbors = list(G.neighbors(node)) # Ensure there are exactly two distinct neighbors if len(neighbors) == 2 and neighbors[0] != neighbors[1]: u, v = neighbors # In a MultiGraph, need to check if there's only one edge between node and each neighbor if isinstance(G, nx.MultiGraph): if G.number_of_edges(node, u) > 1 or G.number_of_edges(node, v) > 1: continue # Skip if there are parallel edges connected to this node # Assuming a single edge, get data for key 0 (default for add_edge in MultiGraph) try: r1 = G[node][u][0].get('resistance', 0) r2 = G[node][v][0].get('resistance', 0) except KeyError: # Handle cases where edge key 0 doesn't exist (unlikely with add_edge but safe) print(f\"Error accessing edge data for node {node} and neighbors {u}, {v}. Skipping series combination.\") continue else: # Standard Graph try: r1 = G[node][u].get('resistance', 0) r2 = G[node][v].get('resistance', 0) except KeyError: print(f\"Error accessing edge data for node {node} and neighbors {u}, {v}. Skipping series combination.\") continue if r1 <= 0 or r2 <= 0: # Check for non-positive resistance print(f\"Warning: Non-positive resistance detected at node {node}. Skipping series combination.\") continue combined = r1 + r2 # Store edges being combined for visualization - assuming single edges in series # For visualization, we only need the node pairs, not keys, for highlight_edges edges_to_highlight = [(node, u), (node, v)] # Modify the graph G.remove_node(node) # When adding edge in MultiGraph, a new key is assigned (usually 0 if first edge) G.add_edge(u, v, resistance=combined) changed = True self.step_count += 1 # Visualize this step title = f\"Step {self.step_count}: Series {u}-{node}-{v} \u2192 {combined:.2f}\u03a9\" self.draw_circuit(G, pos, title, edges_to_highlight) # For visualization steps storage, store the graph copy self.visualization_steps.append((G.copy(), title, edges_to_highlight)) break # Restart iteration after modification if changed: break # Ensure we break after a change to avoid infinite loops def combine_parallel(self, G, pos): \"\"\"Combine parallel resistors with visualization\"\"\" # This function is primarily designed for MultiGraph. # nx.Graph does not support parallel edges. if not isinstance(G, nx.MultiGraph): return # Do nothing if not a MultiGraph changed = True while changed: changed = False parallel_pairs = self._find_parallel_pairs(G) for u, v in parallel_pairs: # Ensure nodes are not terminals unless source/sink are in parallel # We allow combining parallel paths between 'start'/'bas' and 'end'/'son' is_terminal_pair = (u in (\"start\", \"end\", \"bas\", \"son\") and v in (\"start\", \"end\", \"bas\", \"son\")) is_single_terminal = (u in (\"start\", \"end\", \"bas\", \"son\") or v in (\"start\", \"end\", \"bas\", \"son\")) and not is_terminal_pair if is_single_terminal: # Don't combine parallel edges connected to only one terminal unless it's the final source/sink pair continue edges_data = self._get_parallel_edges_data(G, u, v) if len(edges_data) > 1: try: # Check for non-positive resistance to avoid division by zero or invalid calculations if any(e.get('resistance', 0) <= 0 for e in edges_data): print(f\"Warning: Non-positive resistance detected between {u} and {v}. Cannot combine parallel.\") continue # Calculate combined resistance for parallel resistors conductances = [1/e['resistance'] for e in edges_data] combined = 1 / sum(conductances) # Store edges that were combined for visualization (as node pairs) # For visualization, we just need the node pair (u,v) to highlight the connection edges_to_highlight = [(u, v)] # Modify the graph: remove all parallel edges and add a single new one # Need to get the keys before removing keys_to_remove = list(G[u][v].keys()) G.remove_edges_from([(u, v, k) for k in keys_to_remove]) # Add the new combined edge (usually gets key 0 if first edge) G.add_edge(u, v, resistance=combined) changed = True self.step_count += 1 # Visualize this step title = f\"Step {self.step_count}: Parallel {u}-{v} \u2192 {combined:.4f}\u03a9\" # For visualization, pass the node pair for highlighting self.draw_circuit(G, pos, title, edges_to_highlight) # For visualization steps storage, store the graph copy self.visualization_steps.append((G.copy(), title, edges_to_highlight)) break # Restart iteration after modification except KeyError as e: print(f\"Error accessing edge data between {u} and {v}: {e}\") continue if changed: break # Ensure we break after a change to avoid infinite loops def _find_parallel_pairs(self, G): \"\"\"Find all pairs of nodes with parallel edges in a MultiGraph\"\"\" pairs = set() if isinstance(G, nx.MultiGraph): # Iterate through all edges, consider undirected pairs for u, v, key in G.edges(keys=True): # Use a canonical representation for the pair (e.g., sorted tuple) pair = tuple(sorted((u, v))) # Check if there are more than 1 edges between u and v (in either direction for undirected) if G.number_of_edges(u, v) > 1 or G.number_of_edges(v, u) > 1: pairs.add(pair) # No need to check for parallel edges in nx.Graph, as it doesn't support them return list(pairs) def _get_parallel_edges_data(self, G, u, v): \"\"\"Get data for all parallel edges between two nodes in a MultiGraph\"\"\" if isinstance(G, nx.MultiGraph): edge_data_list = [] # Check if the edge (u,v) exists and add its data if u in G and v in G[u]: edge_data_list.extend([G[u][v][key] for key in G[u][v]]) # Check the reverse direction (v,u) as well for undirected graphs if v in G and u in G[v] and u != v: # Avoid adding self-loops twice edge_data_list.extend([G[v][u][key] for key in G[v][u]]) # Remove potential duplicates if an edge was added in both directions (unlikely with how networkx works by default for undirected) # Simple approach: convert to a set of unique edge data dictionaries (requires dictionaries to be hashable, which they are not) # Better approach: collect edge keys seen to avoid duplicates seen_keys = set() unique_edge_data = [] # Iterate through edges (u,v) and (v,u) with keys if u in G and v in G[u]: for key, data in G[u][v].items(): if (u,v,key) not in seen_keys and (v,u,key) not in seen_keys: # Check both directions unique_edge_data.append(data) seen_keys.add((u,v,key)) seen_keys.add((v,u,key)) # Add reverse for undirected check return unique_edge_data return [] # Return empty list if not MultiGraph or no parallel edges def simplify_network(self, G, pos, source, sink): \"\"\"Main function to simplify the resistor network\"\"\" self.step_count = 0 self.visualization_steps = [] # Initial visualization self.draw_circuit(G, pos, \"Original Circuit\") # Make a copy to work with # Use deepcopy if edge attributes might contain mutable objects, though 'resistance' is float. working_graph = G.copy() # Alternate between series and parallel combinations # Use node count as well, as series combination removes nodes prev_state = (len(working_graph.nodes()), len(working_graph.edges())) # Limit the number of iterations to prevent infinite loops in complex or irreducible circuits # A more robust approach might involve tracking visited states or using a more sophisticated simplification algorithm. max_iterations = len(G.nodes()) + len(G.edges()) * 2 # Increased limit slightly iteration_count = 0 while iteration_count < max_iterations: series_changed = False parallel_changed = False # Perform one pass of series combinations nodes_before_series = list(working_graph.nodes()) self.combine_series(working_graph, pos) nodes_after_series = list(working_graph.nodes()) if len(nodes_before_series) != len(nodes_after_series): series_changed = True # Perform one pass of parallel combinations edges_before_parallel = len(list(working_graph.edges())) self.combine_parallel(working_graph, pos) edges_after_parallel = len(list(working_graph.edges())) if edges_before_parallel != edges_after_parallel: parallel_changed = True # Check if we're stuck (no changes in nodes or edges) current_state = (len(working_graph.nodes()), len(list(working_graph.edges()))) if current_state == prev_state: break prev_state = current_state iteration_count += 1 # Check for maximum iterations reached if iteration_count == max_iterations and current_state != prev_state: print(f\"Warning: Maximum iterations ({max_iterations}) reached before full simplification. The circuit might be irreducible by series/parallel combinations or more complex.\") # Final result # Initialize final_resistance to None outside the try block final_resistance = None try: # Check if the graph has been reduced to a single edge between source and sink if working_graph.has_edge(source, sink): # If it's a MultiGraph, there might be multiple parallel edges left between source and sink. # The equivalent resistance is the parallel combination of these. if isinstance(working_graph, nx.MultiGraph) and working_graph.number_of_edges(source, sink) > 1: print(f\"Multiple parallel paths remaining between {source} and {sink}. Calculating final equivalent resistance.\") edges_data = self._get_parallel_edges_data(working_graph, source, sink) if edges_data: # Check for non-positive resistance before calculating if any(e.get('resistance', 0) <= 0 for e in edges_data): print(f\"Warning: Non-positive resistance detected between {source} and {sink}. Cannot calculate final equivalent resistance.\") final_resistance = None # Keep it None or set to NaN else: conductances = [1/e['resistance'] for e in edges_data] final_resistance = 1 / sum(conductances) print(f\"Final equivalent resistance: {final_resistance:.4f}\u03a9\") # Increased precision for final result else: print(f\"No edges found between {source} and {sink} despite has_edge reporting True (unexpected).\") final_resistance = None else: # Simple Graph or MultiGraph with only one edge left final_resistance = working_graph[source][sink].get('resistance') # Use .get() for safety if final_resistance is not None: print(f\"Final equivalent resistance: {final_resistance:.2f}\u03a9\") else: print(f\"Edge between {source} and {sink} found, but resistance attribute is missing.\") else: # This block is executed if no single source-sink edge exists after simplification print(\"Could not reduce to a single equivalent resistance between source and sink.\") # final_resistance remains None, which is now initialized except KeyError as e: print(f\"Error accessing edge data for final resistance between {source} and {sink}: {e}\") final_resistance = None # Ensure it's None in case of error except Exception as e: print(f\"An unexpected error occurred during final resistance calculation: {e}\") final_resistance = None # Draw the final simplified circuit self.draw_circuit(working_graph, pos, f\"Final Simplified Circuit (Steps: {self.step_count})\") return working_graph, final_resistance # ======= Example Circuits ======= # Circuit 1: Series-Parallel Combination (Already in your code) G1 = nx.Graph() G1.add_edge('start', 'A', resistance=4) G1.add_edge('A', 'C', resistance=2) G1.add_edge('start', 'B', resistance=8) G1.add_edge('B', 'C', resistance=4) G1.add_edge('C', 'end', resistance=6) pos1 = { 'start': (0, 0), 'A': (1, 1), 'B': (1, -1), 'C': (2, 0), 'end': (3, 0) } # Circuit 2: Parallel Configuration (Already in your code) G2 = nx.MultiGraph() G2.add_edge('start', 'C', resistance=6) G2.add_edge('start', 'C', resistance=12) G2.add_edge('C', 'end', resistance=6) # This edge is in series with the parallel start-C combination pos2 = { 'start': (0, 0), 'C': (3, 0), 'end': (6, 0) } # --- NEW: Pure Parallel Circuit Example --- G_paralel = nx.MultiGraph() G_paralel.add_edge('bas', 'son', resistance=10) G_paralel.add_edge('bas', 'son', resistance=15) G_paralel.add_edge('bas', 'son', resistance=30) pos_paralel = { 'bas': (0, 0), 'son': (1, 0) } # ---------------------------------------- # Create analyzer instance analyzer = ResistorNetworkAnalyzer() # Analyze first circuit print(\"\\nAnalyzing Circuit 1\") simplified_G1, R_eq1 = analyzer.simplify_network(G1, pos1, 'start', 'end') if R_eq1 is not None: print(f\"Result for Circuit 1: R_eq = {R_eq1:.2f}\u03a9\") else: print(\"Could not determine equivalent resistance for Circuit 1.\") # Analyze second circuit print(\"\\nAnalyzing Circuit 2\") simplified_G2, R_eq2 = analyzer.simplify_network(G2, pos2, 'start', 'end') if R_eq2 is not None: print(f\"Result for Circuit 2: R_eq = {R_eq2:.2f}\u03a9\") else: print(\"Could not determine equivalent resistance for Circuit 2.\") # --- Analyze the Pure Parallel Circuit --- print(\"\\nAnalyzing Pure Parallel Circuit\") simplified_G_paralel, R_eq_paralel = analyzer.simplify_network(G_paralel, pos_paralel, 'bas', 'son') if R_eq_paralel is not None: print(f\"Result for Pure Parallel Circuit: R_eq = {R_eq_paralel:.2f}\u03a9\") else: print(\"Could not determine equivalent resistance for Pure Parallel Circuit.\") # ------------------------------------------","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction-and-motivation","text":"Calculating equivalent resistance is a fundamental task in circuit analysis. While traditional approaches use series and parallel simplification rules manually, graph theory provides a powerful alternative \u2013 transforming circuit analysis into an algorithmic graph simplification process. Circuits can be represented as graphs: - Nodes = junctions - Edges = resistors (with resistance as weight) By identifying series and parallel patterns in the graph, we can iteratively reduce it to compute total resistance between two terminals. This approach is: - Scalable for large networks - Automatable for software - Insightful for understanding electrical connectivity and topology","title":"Introduction and Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#learning-goals","text":"After completing this task, you should be able to: Represent a resistor network as a weighted graph. Apply reduction rules (series and parallel) using graph algorithms. Implement an algorithm that simplifies arbitrary configurations. Analyze different circuit structures programmatically.","title":"Learning Goals"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm","text":"The circuit is modeled as a multigraph G = (V, E), where V is the set of junctions (nodes) and E is the set of resistors (edges). Each edge e \u2208 E has a weight r_e representing its resistance. Two distinct nodes, start_node and end_node , are specified as the terminals across which the equivalent resistance is sought. The algorithm proceeds as follows: Initialization: Construct the graph from the given circuit components. Validate that start_node and end_node exist in the graph. If start_node = end_node , the resistance is 0\u03a9. Iterative Reduction: Repeatedly apply the following reduction rules until no more simple series or parallel reductions are possible, or the graph is reduced to a single edge between start_node and end_node . Parallel Reduction: Identification: Find any pair of nodes (u, v) connected by two or more edges (resistors R\u2081, R\u2082, ..., R_k). Reduction: Replace these k parallel resistors with a single equivalent resistor R_p between u and v. The equivalent resistance is calculated as: ( R_p = (\u03a3\u1d62\u208c\u2081\u1d4f 1/R_i)\u207b\u00b9 ) if any R_i = 0, R_p = 0. If all R_i = \u221e, R_p = \u221e. Action: Remove the original k edges and add a new edge (u, v) with resistance R_p. If R_p = \u221e, effectively remove the connection unless it's the only path. After a reduction, restart the scan for further simplifications as the graph structure has changed.","title":"Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-reduction","text":"Identification: Find any node w such that: w is not the start_node or end_node . The degree of w, deg(w), is exactly 2. Let the two edges incident to w be (u, w) with resistance R\u2081, and (w, v) with resistance R\u2082. Ensure u \u2260 v\u2081 (if u = v, it's a loop, not a simple series element in a path from start_node to end_node ). Reduction: Replace the two series resistors R\u2081 and R\u2082, and the intermediate node w with a single equivalent resistor R_s between u and v. The equivalent resistance is: ( R_s = R\u2081 + R\u2082 ) if R\u2081 = \u221e or R\u2082 = \u221e, then R_s = \u221e. Action: Remove node w (which also removes edges (u, w) and (w, v)). Add a new edge (u, v) with resistance R_s. If R_s = \u221e, effectively this path segment becomes an open circuit. After a reduction, restart the scan. Reduction: Replace these k parallel resistors with a single equivalent resistor R_p between u and v. The equivalent resistance is calculated as: ( R_p = (\u03a3\u1d62\u208c\u2081\u1d4f 1/R_i)\u207b\u00b9 ) if any R_i = 0, R_p = 0. If all R_i = \u221e, R_p = \u221e. Action: Remove the original k edges and add a new edge (u, v) with resistance R_p. If R_p = \u221e, effectively remove the connection unless it's the only path. After a reduction, restart the scan for further simplifications as the graph structure has changed. Action: Remove node w (which also removes edges (u, w) and (w, v)). Add a new edge (u, v) with resistance R_s. If R_s = \u221e, effectively this path segment becomes an open circuit. After a reduction, restart the scan.","title":"Series Reduction:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#termination-and-result","text":"The loop terminates if no series or parallel reductions were made in a full pass. Ideal Case: If the graph is reduced to a single edge between start_node and end_node , its resistance is the equivalent resistance. Final Parallel Case: If the graph consists of only start_node and end_node and multiple edges directly connecting them, these are in parallel. Calculate their combined parallel resistance. Non-Reducible Case: If the graph cannot be simplified further by these rules to one of the above states, the circuit may contain non-series-parallel configurations (e.g., a Wheatstone bridge not in balance). The algorithm, in this form, will report that it cannot fully reduce the circuit. Open Circuit: If, at any point or at the end, there is no path between start_node and end_node , the equivalent resistance is \u221e. Short Circuit: If an equivalent resistance of 0\u03a9 is found.","title":"Termination and Result:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-connection","text":"Two resistors R\u2081 and R\u2082 in series: R_eq = R\u2081 + R\u2082","title":"Series Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-connection","text":"Two resistors R\u2081 and R\u2082 in parallel: 1/R_eq = 1/R\u2081 + 1/R\u2082 => R_eq = (1/R\u2081 + 1/R\u2082)\u207b\u00b9","title":"Parallel Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#phyton-implemntaion","text":"from IPython import get_ipython from IPython.display import display import matplotlib.pyplot as plt import networkx as nx class ResistorNetworkAnalyzer: def __init__(self): self.step_count = 0 self.visualization_steps = [] def _get_edge_labels(self, G): \"\"\"Helper function to generate edge labels with resistance values\"\"\" edge_labels = {} for u, v, data in G.edges(data=True): if 'resistance' in data: # Handle MultiGraph key access here as well if isinstance(G, nx.MultiGraph) and len(G[u][v]) > 1: # If multiple edges, show all resistances labels = [f\"{d.get('resistance', 0):.2f}\u03a9\" for k, d in G[u][v].items()] edge_labels[(u, v)] = ', '.join(labels) else: edge_labels[(u, v)] = f\"{data['resistance']:.2f}\u03a9\" # Removed the redundant elif for MultiGraph, handled above return edge_labels def draw_circuit(self, G, pos, title, highlight_edges=None): \"\"\"Improved visualization function with better highlighting\"\"\" plt.figure(figsize=(10, 6)) # Node styling - T\u00fcm d\u00fc\u011f\u00fcmler k\u0131rm\u0131z\u0131 ve kare \u015feklinde node_colors = ['#FF0000' for node in G.nodes()] # T\u00fcm d\u00fc\u011f\u00fcmler i\u00e7in k\u0131rm\u0131z\u0131 renk nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=1800, node_shape='s', edgecolors='black', linewidths=2) # Kare \u015fekil nx.draw_networkx_labels(G, pos, font_size=14, font_weight='bold') # Draw all edges # Need to handle MultiGraph edges explicitly for drawing if isinstance(G, nx.MultiGraph): # Draw each edge individually for MultiGraphs for u, v, key, data in G.edges(keys=True, data=True): # Use connectionstyle to curve parallel edges for better visibility nx.draw_networkx_edges(G, pos, edgelist=[(u,v)], width=2, edge_color='black', connectionstyle='arc3,rad=0.1') else: nx.draw_networkx_edges(G, pos, width=2, edge_color='black') # Highlight edges that were modified if highlight_edges: # Need to handle MultiGraph highlighting carefully if isinstance(G, nx.MultiGraph): highlight_edges_with_keys = [] for u, v in highlight_edges: if G.has_edge(u, v): # Highlight all edges between u and v (assuming highlight_edges contains the pairs that were combined) # A more precise highlighting would require knowing the keys of the edges that were removed. # For visualization purposes, highlighting the path between nodes u and v is often sufficient. for key in G[u][v]: highlight_edges_with_keys.append((u, v, key)) if highlight_edges_with_keys: nx.draw_networkx_edges(G, pos, edgelist=highlight_edges_with_keys, edge_color='#FF5722', width=6, alpha=0.7, connectionstyle='arc3,rad=0.1') else: nx.draw_networkx_edges(G, pos, edgelist=highlight_edges, edge_color='#FF5722', width=6, alpha=0.7) # Edge labels with resistance values edge_labels = self._get_edge_labels(G) # nx.draw_networkx_edge_labels has issues with MultiGraph parallel edges. # It often labels only one of the parallel edges or overlaps labels. # A more advanced labeling for MultiGraphs might involve manually positioning labels. # For this example, we will keep the standard labeling, but be aware of limitations. nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=12, bbox=dict(facecolor='white', edgecolor='none', alpha=0.8, boxstyle='round,pad=0.3')) plt.title(title, fontsize=16, pad=20) plt.axis('off') plt.tight_layout() # Check if running in a Jupyter environment before trying to display ipython = get_ipython() if ipython is not None: display(plt.gcf()) # Use display for inline plotting in Jupyter else: plt.show() # Fallback for non-Jupyter environments plt.close() # Close the figure after showing to prevent memory issues def combine_series(self, G, pos): \"\"\"Combine series resistors with visualization\"\"\" changed = True while changed: changed = False for node in list(G.nodes): # Exclude terminal nodes and check degree # For MultiGraph, degree counts each edge if node not in (\"start\", \"end\", \"bas\", \"son\") and G.degree(node) == 2: neighbors = list(G.neighbors(node)) # Ensure there are exactly two distinct neighbors if len(neighbors) == 2 and neighbors[0] != neighbors[1]: u, v = neighbors # In a MultiGraph, need to check if there's only one edge between node and each neighbor if isinstance(G, nx.MultiGraph): if G.number_of_edges(node, u) > 1 or G.number_of_edges(node, v) > 1: continue # Skip if there are parallel edges connected to this node # Assuming a single edge, get data for key 0 (default for add_edge in MultiGraph) try: r1 = G[node][u][0].get('resistance', 0) r2 = G[node][v][0].get('resistance', 0) except KeyError: # Handle cases where edge key 0 doesn't exist (unlikely with add_edge but safe) print(f\"Error accessing edge data for node {node} and neighbors {u}, {v}. Skipping series combination.\") continue else: # Standard Graph try: r1 = G[node][u].get('resistance', 0) r2 = G[node][v].get('resistance', 0) except KeyError: print(f\"Error accessing edge data for node {node} and neighbors {u}, {v}. Skipping series combination.\") continue if r1 <= 0 or r2 <= 0: # Check for non-positive resistance print(f\"Warning: Non-positive resistance detected at node {node}. Skipping series combination.\") continue combined = r1 + r2 # Store edges being combined for visualization - assuming single edges in series # For visualization, we only need the node pairs, not keys, for highlight_edges edges_to_highlight = [(node, u), (node, v)] # Modify the graph G.remove_node(node) # When adding edge in MultiGraph, a new key is assigned (usually 0 if first edge) G.add_edge(u, v, resistance=combined) changed = True self.step_count += 1 # Visualize this step title = f\"Step {self.step_count}: Series {u}-{node}-{v} \u2192 {combined:.2f}\u03a9\" self.draw_circuit(G, pos, title, edges_to_highlight) # For visualization steps storage, store the graph copy self.visualization_steps.append((G.copy(), title, edges_to_highlight)) break # Restart iteration after modification if changed: break # Ensure we break after a change to avoid infinite loops def combine_parallel(self, G, pos): \"\"\"Combine parallel resistors with visualization\"\"\" # This function is primarily designed for MultiGraph. # nx.Graph does not support parallel edges. if not isinstance(G, nx.MultiGraph): return # Do nothing if not a MultiGraph changed = True while changed: changed = False parallel_pairs = self._find_parallel_pairs(G) for u, v in parallel_pairs: # Ensure nodes are not terminals unless source/sink are in parallel # We allow combining parallel paths between 'start'/'bas' and 'end'/'son' is_terminal_pair = (u in (\"start\", \"end\", \"bas\", \"son\") and v in (\"start\", \"end\", \"bas\", \"son\")) is_single_terminal = (u in (\"start\", \"end\", \"bas\", \"son\") or v in (\"start\", \"end\", \"bas\", \"son\")) and not is_terminal_pair if is_single_terminal: # Don't combine parallel edges connected to only one terminal unless it's the final source/sink pair continue edges_data = self._get_parallel_edges_data(G, u, v) if len(edges_data) > 1: try: # Check for non-positive resistance to avoid division by zero or invalid calculations if any(e.get('resistance', 0) <= 0 for e in edges_data): print(f\"Warning: Non-positive resistance detected between {u} and {v}. Cannot combine parallel.\") continue # Calculate combined resistance for parallel resistors conductances = [1/e['resistance'] for e in edges_data] combined = 1 / sum(conductances) # Store edges that were combined for visualization (as node pairs) # For visualization, we just need the node pair (u,v) to highlight the connection edges_to_highlight = [(u, v)] # Modify the graph: remove all parallel edges and add a single new one # Need to get the keys before removing keys_to_remove = list(G[u][v].keys()) G.remove_edges_from([(u, v, k) for k in keys_to_remove]) # Add the new combined edge (usually gets key 0 if first edge) G.add_edge(u, v, resistance=combined) changed = True self.step_count += 1 # Visualize this step title = f\"Step {self.step_count}: Parallel {u}-{v} \u2192 {combined:.4f}\u03a9\" # For visualization, pass the node pair for highlighting self.draw_circuit(G, pos, title, edges_to_highlight) # For visualization steps storage, store the graph copy self.visualization_steps.append((G.copy(), title, edges_to_highlight)) break # Restart iteration after modification except KeyError as e: print(f\"Error accessing edge data between {u} and {v}: {e}\") continue if changed: break # Ensure we break after a change to avoid infinite loops def _find_parallel_pairs(self, G): \"\"\"Find all pairs of nodes with parallel edges in a MultiGraph\"\"\" pairs = set() if isinstance(G, nx.MultiGraph): # Iterate through all edges, consider undirected pairs for u, v, key in G.edges(keys=True): # Use a canonical representation for the pair (e.g., sorted tuple) pair = tuple(sorted((u, v))) # Check if there are more than 1 edges between u and v (in either direction for undirected) if G.number_of_edges(u, v) > 1 or G.number_of_edges(v, u) > 1: pairs.add(pair) # No need to check for parallel edges in nx.Graph, as it doesn't support them return list(pairs) def _get_parallel_edges_data(self, G, u, v): \"\"\"Get data for all parallel edges between two nodes in a MultiGraph\"\"\" if isinstance(G, nx.MultiGraph): edge_data_list = [] # Check if the edge (u,v) exists and add its data if u in G and v in G[u]: edge_data_list.extend([G[u][v][key] for key in G[u][v]]) # Check the reverse direction (v,u) as well for undirected graphs if v in G and u in G[v] and u != v: # Avoid adding self-loops twice edge_data_list.extend([G[v][u][key] for key in G[v][u]]) # Remove potential duplicates if an edge was added in both directions (unlikely with how networkx works by default for undirected) # Simple approach: convert to a set of unique edge data dictionaries (requires dictionaries to be hashable, which they are not) # Better approach: collect edge keys seen to avoid duplicates seen_keys = set() unique_edge_data = [] # Iterate through edges (u,v) and (v,u) with keys if u in G and v in G[u]: for key, data in G[u][v].items(): if (u,v,key) not in seen_keys and (v,u,key) not in seen_keys: # Check both directions unique_edge_data.append(data) seen_keys.add((u,v,key)) seen_keys.add((v,u,key)) # Add reverse for undirected check return unique_edge_data return [] # Return empty list if not MultiGraph or no parallel edges def simplify_network(self, G, pos, source, sink): \"\"\"Main function to simplify the resistor network\"\"\" self.step_count = 0 self.visualization_steps = [] # Initial visualization self.draw_circuit(G, pos, \"Original Circuit\") # Make a copy to work with # Use deepcopy if edge attributes might contain mutable objects, though 'resistance' is float. working_graph = G.copy() # Alternate between series and parallel combinations # Use node count as well, as series combination removes nodes prev_state = (len(working_graph.nodes()), len(working_graph.edges())) # Limit the number of iterations to prevent infinite loops in complex or irreducible circuits # A more robust approach might involve tracking visited states or using a more sophisticated simplification algorithm. max_iterations = len(G.nodes()) + len(G.edges()) * 2 # Increased limit slightly iteration_count = 0 while iteration_count < max_iterations: series_changed = False parallel_changed = False # Perform one pass of series combinations nodes_before_series = list(working_graph.nodes()) self.combine_series(working_graph, pos) nodes_after_series = list(working_graph.nodes()) if len(nodes_before_series) != len(nodes_after_series): series_changed = True # Perform one pass of parallel combinations edges_before_parallel = len(list(working_graph.edges())) self.combine_parallel(working_graph, pos) edges_after_parallel = len(list(working_graph.edges())) if edges_before_parallel != edges_after_parallel: parallel_changed = True # Check if we're stuck (no changes in nodes or edges) current_state = (len(working_graph.nodes()), len(list(working_graph.edges()))) if current_state == prev_state: break prev_state = current_state iteration_count += 1 # Check for maximum iterations reached if iteration_count == max_iterations and current_state != prev_state: print(f\"Warning: Maximum iterations ({max_iterations}) reached before full simplification. The circuit might be irreducible by series/parallel combinations or more complex.\") # Final result # Initialize final_resistance to None outside the try block final_resistance = None try: # Check if the graph has been reduced to a single edge between source and sink if working_graph.has_edge(source, sink): # If it's a MultiGraph, there might be multiple parallel edges left between source and sink. # The equivalent resistance is the parallel combination of these. if isinstance(working_graph, nx.MultiGraph) and working_graph.number_of_edges(source, sink) > 1: print(f\"Multiple parallel paths remaining between {source} and {sink}. Calculating final equivalent resistance.\") edges_data = self._get_parallel_edges_data(working_graph, source, sink) if edges_data: # Check for non-positive resistance before calculating if any(e.get('resistance', 0) <= 0 for e in edges_data): print(f\"Warning: Non-positive resistance detected between {source} and {sink}. Cannot calculate final equivalent resistance.\") final_resistance = None # Keep it None or set to NaN else: conductances = [1/e['resistance'] for e in edges_data] final_resistance = 1 / sum(conductances) print(f\"Final equivalent resistance: {final_resistance:.4f}\u03a9\") # Increased precision for final result else: print(f\"No edges found between {source} and {sink} despite has_edge reporting True (unexpected).\") final_resistance = None else: # Simple Graph or MultiGraph with only one edge left final_resistance = working_graph[source][sink].get('resistance') # Use .get() for safety if final_resistance is not None: print(f\"Final equivalent resistance: {final_resistance:.2f}\u03a9\") else: print(f\"Edge between {source} and {sink} found, but resistance attribute is missing.\") else: # This block is executed if no single source-sink edge exists after simplification print(\"Could not reduce to a single equivalent resistance between source and sink.\") # final_resistance remains None, which is now initialized except KeyError as e: print(f\"Error accessing edge data for final resistance between {source} and {sink}: {e}\") final_resistance = None # Ensure it's None in case of error except Exception as e: print(f\"An unexpected error occurred during final resistance calculation: {e}\") final_resistance = None # Draw the final simplified circuit self.draw_circuit(working_graph, pos, f\"Final Simplified Circuit (Steps: {self.step_count})\") return working_graph, final_resistance # ======= Example Circuits ======= # Circuit 1: Series-Parallel Combination (Already in your code) G1 = nx.Graph() G1.add_edge('start', 'A', resistance=4) G1.add_edge('A', 'C', resistance=2) G1.add_edge('start', 'B', resistance=8) G1.add_edge('B', 'C', resistance=4) G1.add_edge('C', 'end', resistance=6) pos1 = { 'start': (0, 0), 'A': (1, 1), 'B': (1, -1), 'C': (2, 0), 'end': (3, 0) } # Circuit 2: Parallel Configuration (Already in your code) G2 = nx.MultiGraph() G2.add_edge('start', 'C', resistance=6) G2.add_edge('start', 'C', resistance=12) G2.add_edge('C', 'end', resistance=6) # This edge is in series with the parallel start-C combination pos2 = { 'start': (0, 0), 'C': (3, 0), 'end': (6, 0) } # --- NEW: Pure Parallel Circuit Example --- G_paralel = nx.MultiGraph() G_paralel.add_edge('bas', 'son', resistance=10) G_paralel.add_edge('bas', 'son', resistance=15) G_paralel.add_edge('bas', 'son', resistance=30) pos_paralel = { 'bas': (0, 0), 'son': (1, 0) } # ---------------------------------------- # Create analyzer instance analyzer = ResistorNetworkAnalyzer() # Analyze first circuit print(\"\\nAnalyzing Circuit 1\") simplified_G1, R_eq1 = analyzer.simplify_network(G1, pos1, 'start', 'end') if R_eq1 is not None: print(f\"Result for Circuit 1: R_eq = {R_eq1:.2f}\u03a9\") else: print(\"Could not determine equivalent resistance for Circuit 1.\") # Analyze second circuit print(\"\\nAnalyzing Circuit 2\") simplified_G2, R_eq2 = analyzer.simplify_network(G2, pos2, 'start', 'end') if R_eq2 is not None: print(f\"Result for Circuit 2: R_eq = {R_eq2:.2f}\u03a9\") else: print(\"Could not determine equivalent resistance for Circuit 2.\") # --- Analyze the Pure Parallel Circuit --- print(\"\\nAnalyzing Pure Parallel Circuit\") simplified_G_paralel, R_eq_paralel = analyzer.simplify_network(G_paralel, pos_paralel, 'bas', 'son') if R_eq_paralel is not None: print(f\"Result for Pure Parallel Circuit: R_eq = {R_eq_paralel:.2f}\u03a9\") else: print(\"Could not determine equivalent resistance for Pure Parallel Circuit.\") # ------------------------------------------","title":"Phyton \u0130mplemntaion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem Through Simulations Motivation The Central Limit Theorem (CLT) is a cornerstone of statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases \u2013 regardless of the population's original distribution. Simulations help visualize and understand this concept in an intuitive way. Problem Overview Objective Use Python simulations to explore how sample means from various population distributions approach a normal distribution as sample size increases. Tasks 1. Simulating Sampling Distributions Select different population distributions to simulate: Uniform distribution Exponential distribution Binomial distribution For each, generate a large dataset representing the population (e.g., 100,000 values). 2. Sampling and Visualization Randomly draw samples of varying sizes (e.g., \\(n = 5, 10, 30, 50\\) ) from the population. Calculate the sample mean for each draw. Repeat the process (e.g., 1,000 times) to build a sampling distribution. Plot histograms of these sample means and observe their shapes. 3. Parameter Exploration Explore the following: How the original distribution's shape affects the rate of convergence to normality. How sample size influences convergence. The effect of population variance on the spread of the sampling distribution. 4. Real-World Applications Understand the significance of CLT in practical scenarios: Estimating population parameters from samples Quality control and process monitoring Financial modeling and risk assessment Simulation Details We simulate data from the following population distributions: Uniform distribution Exponential distribution Binomial distribution For each distribution: A population of 100,000 values is generated Samples of sizes \\(n = 5, 10, 30, 50\\) are drawn repeatedly (1,000 times) Sample means are calculated and plotted as histograms Phyton \u0130mplemaentation ```python import numpy as np import matplotlib.pyplot as plt import seaborn as sns import math def generate_population(dist, size=100_000, **kwargs): if dist == 'uniform': return np.random.uniform(kwargs.get('low', 0), kwargs.get('high', 1), size) if dist == 'exponential': return np.random.exponential(kwargs.get('scale', 1.0), size) if dist == 'binomial': return np.random.binomial(kwargs.get('n', 10), kwargs.get('p', 0.5), size) raise ValueError(f\"Unknown distribution: {dist}\") def sample_means(pop, sample_size, n_samples=1000): return [np.mean(np.random.choice(pop, sample_size, replace=False)) for _ in range(n_samples)] def plot_sampling_dists(populations, sample_sizes, n_samples=1000, bins=30): for name, pop in populations.items(): num_sizes = len(sample_sizes) rows = math.ceil(num_sizes / 2) cols = 2 if num_sizes > 1 else 1 plt.figure(figsize=(6 * cols, 4 * rows)) for i, n in enumerate(sample_sizes, 1): means = sample_means(pop, n, n_samples) plt.subplot(rows, cols, i) sns.histplot(means, kde=True, bins=bins) plt.title(f\"{name.title()} Distribution\\nSample Size = {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.grid(True) plt.suptitle(f\"Sampling Distributions of Sample Means - {name.title()}\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.show() if name == \" main \": dists = { 'uniform': {'low': 0, 'high': 1}, 'exponential':{'scale': 2.0}, 'binomial': {'n': 10, 'p': 0.3}, } pops = {name: generate_population(name, **params) for name, params in dists.items()} sizes = [5, 10, 30, 50] plot_sampling_dists(pops, sizes) ```","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a cornerstone of statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases \u2013 regardless of the population's original distribution. Simulations help visualize and understand this concept in an intuitive way.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-overview","text":"","title":"Problem Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"Use Python simulations to explore how sample means from various population distributions approach a normal distribution as sample size increases.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#tasks","text":"","title":"Tasks"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"Select different population distributions to simulate: Uniform distribution Exponential distribution Binomial distribution For each, generate a large dataset representing the population (e.g., 100,000 values).","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"Randomly draw samples of varying sizes (e.g., \\(n = 5, 10, 30, 50\\) ) from the population. Calculate the sample mean for each draw. Repeat the process (e.g., 1,000 times) to build a sampling distribution. Plot histograms of these sample means and observe their shapes.","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"Explore the following: How the original distribution's shape affects the rate of convergence to normality. How sample size influences convergence. The effect of population variance on the spread of the sampling distribution.","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-real-world-applications","text":"Understand the significance of CLT in practical scenarios: Estimating population parameters from samples Quality control and process monitoring Financial modeling and risk assessment","title":"4. Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-details","text":"We simulate data from the following population distributions: Uniform distribution Exponential distribution Binomial distribution","title":"Simulation Details"},{"location":"1%20Physics/6%20Statistics/Problem_1/#for-each-distribution","text":"A population of 100,000 values is generated Samples of sizes \\(n = 5, 10, 30, 50\\) are drawn repeatedly (1,000 times) Sample means are calculated and plotted as histograms","title":"For each distribution:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#phyton-implemaentation","text":"```python import numpy as np import matplotlib.pyplot as plt import seaborn as sns import math def generate_population(dist, size=100_000, **kwargs): if dist == 'uniform': return np.random.uniform(kwargs.get('low', 0), kwargs.get('high', 1), size) if dist == 'exponential': return np.random.exponential(kwargs.get('scale', 1.0), size) if dist == 'binomial': return np.random.binomial(kwargs.get('n', 10), kwargs.get('p', 0.5), size) raise ValueError(f\"Unknown distribution: {dist}\") def sample_means(pop, sample_size, n_samples=1000): return [np.mean(np.random.choice(pop, sample_size, replace=False)) for _ in range(n_samples)] def plot_sampling_dists(populations, sample_sizes, n_samples=1000, bins=30): for name, pop in populations.items(): num_sizes = len(sample_sizes) rows = math.ceil(num_sizes / 2) cols = 2 if num_sizes > 1 else 1 plt.figure(figsize=(6 * cols, 4 * rows)) for i, n in enumerate(sample_sizes, 1): means = sample_means(pop, n, n_samples) plt.subplot(rows, cols, i) sns.histplot(means, kde=True, bins=bins) plt.title(f\"{name.title()} Distribution\\nSample Size = {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.grid(True) plt.suptitle(f\"Sampling Distributions of Sample Means - {name.title()}\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.show() if name == \" main \": dists = { 'uniform': {'low': 0, 'high': 1}, 'exponential':{'scale': 2.0}, 'binomial': {'n': 10, 'p': 0.3}, } pops = {name: generate_population(name, **params) for name, params in dists.items()} sizes = [5, 10, 30, 50] plot_sampling_dists(pops, sizes) ```","title":"Phyton \u0130mplemaentation"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods Introduction Monte Carlo simulations are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. One elegant and accessible application is estimating the value of \u03c0 through probability and geometry. This project explores two Monte Carlo techniques for estimating \u03c0: Using random points inside a square and circle Using Buffon's Needle experiment These simulations provide visual insight into the relationship between randomness and mathematical constants. Method 1: Monte Carlo Estimation with Random Points Concept Imagine a square with a circle inscribed inside it. If you randomly generate points in the square, the proportion of points that fall inside the circle is related to \u03c0. Let: - The square be of size 2\u00d72 (centered at the origin) - The circle have a radius of 1 Then the area ratio is: \\[ \\pi \\approx 4 \\times \\left(\\frac{\\text{points inside circle}}{\\text{total points}}\\right) \\] As the number of points increases, this ratio converges to \u03c0. Method 2: Buffon's Needle Experiment Concept Buffon's Needle is a classic probability problem where a needle of length \\(L\\) is dropped on a floor with parallel lines spaced \\(D\\) units apart. The probability \\(P\\) that the needle crosses a line is related to \u03c0 by: \\[ \\pi \\approx \\frac{(2 \\times L \\times \\text{number of throws})}{(D \\times \\text{number of crossings})} \\] This method uses randomness and geometry to estimate \u03c0 through repeated trials. PHyton \u0130mplementation import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points=10000, visualize=True): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points if visualize: plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, color='green', label='Inside Circle') plt.scatter(x[~inside], y[~inside], s=1, color='red', label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False) plt.gca().add_artist(circle) plt.title(f'\u03c0 Estimate (Circle Method): {pi_estimate:.5f} (n={n_points})') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.legend() plt.grid(True) plt.tight_layout() plt.show() return pi_estimate def convergence_analysis(): trials = [10, 100, 1000, 5000, 10000, 50000, 100000] estimates_circle = [estimate_pi_circle(n, visualize=False) for n in trials] estimates_buffon = [estimate_pi_buffon(n, visualize=False) for n in trials] plt.figure(figsize=(10, 5)) plt.plot(trials, estimates_circle, label=\"Circle Method\", marker='o') plt.plot(trials, estimates_buffon, label=\"Buffon's Needle\", marker='s') plt.axhline(np.pi, color='gray', linestyle='--', label='True \u03c0') for x, y in zip(trials, estimates_circle): plt.text(x, y + 0.05, f\"{y:.4f}\", fontsize=8, ha='center', color='green') for x, y in zip(trials, estimates_buffon): plt.text(x, y - 0.1, f\"{y:.4f}\", fontsize=8, ha='center', color='blue') plt.xscale(\"log\") plt.xlabel(\"Number of Simulations (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimation Methods\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": print(\"Estimating \u03c0 using Circle Method:\") pi_circle = estimate_pi_circle(10000) print(\"\\nEstimating \u03c0 using Buffon's Needle Method:\") pi_buffon = estimate_pi_buffon(100000) print(\"\\nRunning Convergence Analysis:\") convergence_analysis()","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#introduction","text":"Monte Carlo simulations are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. One elegant and accessible application is estimating the value of \u03c0 through probability and geometry. This project explores two Monte Carlo techniques for estimating \u03c0: Using random points inside a square and circle Using Buffon's Needle experiment These simulations provide visual insight into the relationship between randomness and mathematical constants.","title":"Introduction"},{"location":"1%20Physics/6%20Statistics/Problem_2/#method-1-monte-carlo-estimation-with-random-points","text":"","title":"Method 1: Monte Carlo Estimation with Random Points"},{"location":"1%20Physics/6%20Statistics/Problem_2/#concept","text":"Imagine a square with a circle inscribed inside it. If you randomly generate points in the square, the proportion of points that fall inside the circle is related to \u03c0. Let: - The square be of size 2\u00d72 (centered at the origin) - The circle have a radius of 1 Then the area ratio is: \\[ \\pi \\approx 4 \\times \\left(\\frac{\\text{points inside circle}}{\\text{total points}}\\right) \\] As the number of points increases, this ratio converges to \u03c0.","title":"Concept"},{"location":"1%20Physics/6%20Statistics/Problem_2/#method-2-buffons-needle-experiment","text":"","title":"Method 2: Buffon's Needle Experiment"},{"location":"1%20Physics/6%20Statistics/Problem_2/#concept_1","text":"Buffon's Needle is a classic probability problem where a needle of length \\(L\\) is dropped on a floor with parallel lines spaced \\(D\\) units apart. The probability \\(P\\) that the needle crosses a line is related to \u03c0 by: \\[ \\pi \\approx \\frac{(2 \\times L \\times \\text{number of throws})}{(D \\times \\text{number of crossings})} \\] This method uses randomness and geometry to estimate \u03c0 through repeated trials.","title":"Concept"},{"location":"1%20Physics/6%20Statistics/Problem_2/#phyton-implementation","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points=10000, visualize=True): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points if visualize: plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, color='green', label='Inside Circle') plt.scatter(x[~inside], y[~inside], s=1, color='red', label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False) plt.gca().add_artist(circle) plt.title(f'\u03c0 Estimate (Circle Method): {pi_estimate:.5f} (n={n_points})') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.legend() plt.grid(True) plt.tight_layout() plt.show() return pi_estimate def convergence_analysis(): trials = [10, 100, 1000, 5000, 10000, 50000, 100000] estimates_circle = [estimate_pi_circle(n, visualize=False) for n in trials] estimates_buffon = [estimate_pi_buffon(n, visualize=False) for n in trials] plt.figure(figsize=(10, 5)) plt.plot(trials, estimates_circle, label=\"Circle Method\", marker='o') plt.plot(trials, estimates_buffon, label=\"Buffon's Needle\", marker='s') plt.axhline(np.pi, color='gray', linestyle='--', label='True \u03c0') for x, y in zip(trials, estimates_circle): plt.text(x, y + 0.05, f\"{y:.4f}\", fontsize=8, ha='center', color='green') for x, y in zip(trials, estimates_buffon): plt.text(x, y - 0.1, f\"{y:.4f}\", fontsize=8, ha='center', color='blue') plt.xscale(\"log\") plt.xlabel(\"Number of Simulations (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimation Methods\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": print(\"Estimating \u03c0 using Circle Method:\") pi_circle = estimate_pi_circle(10000) print(\"\\nEstimating \u03c0 using Buffon's Needle Method:\") pi_buffon = estimate_pi_buffon(100000) print(\"\\nRunning Convergence Analysis:\") convergence_analysis()","title":"PHyton \u0130mplementation"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity, \\(g\\) , is a fundamental constant in physics. Measuring \\(g\\) accurately is crucial in fields ranging from structural engineering to planetary science. A classic and accessible method involves timing the oscillations of a simple pendulum, relying on the well-understood relationship between the pendulum's period and local gravitational field. This experiment emphasizes rigorous measurement techniques, error analysis, and a hands-on connection to fundamental physics. Objective Estimate the gravitational acceleration \\(g\\) by measuring the period of a simple pendulum and performing a full uncertainty analysis. Materials String: 1.0\u20131.5 meters long Mass: e.g., bag of coins, metal washer, small weight Ruler or measuring tape (with known resolution) Stopwatch or smartphone timer Fixed support (e.g., hook, rod, table edge) Procedure 1. Setup Construct the pendulum by tying the weight securely to one end of the string. Fix the other end to a support so that the pendulum can swing freely. Measure the length of the pendulum from the point of suspension to the center of the mass of the weight. Notation: Let \\(L\\) be the length of the pendulum (in meters) \\[ \\Delta L = \\frac{\\text{(resolution of measuring tool)}}{2} \\] Sample Data Table Trial Time for 10 Oscillations ( \\(T_{10}\\) ) [s] 1 20.4 2 20.2 3 20.5 4 20.3 5 20.4 6 20.2 7 20.3 8 20.4 9 20.1 10 20.3 Let: Mean time: \\( \\bar{T}_{10} = \\frac{1}{10} \\sum T_{10} \\) Standard deviation: \\( \\sigma_{T} \\) Uncertainty in mean: \\( \\Delta \\bar{T}_{10} = \\frac{\\sigma_{T}}{\\sqrt{n}} \\) where \\(n = 10\\) Calculations 1. Period of One Oscillation \\[ T = \\frac{\\bar{T}_{10}}{10} \\] \\[ \\Delta T = \\frac{\\Delta \\bar{T}_{10}}{10} \\] 2. Gravitational Acceleration \\[ g = \\frac{4 \\pi^2 L}{T^2} \\] 3. Uncertainty in \\(g\\) \\[ \\Delta g = g \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( \\frac{2 \\Delta T}{T} \\right)^2 } \\] Results Summary Quantity Value Uncertainty Pendulum Length \\(L\\) 1.0000 m \u00b10.005 m Mean Time \\(T_{10}\\) 20.31 s \u00b10.10 s Period \\(T\\) 2.031 s \u00b10.010 s Calculated \\(g\\) 9.55 m/s\u00b2 \u00b10.18 m/s\u00b2 Analysis Comparison Standard gravitational acceleration: 9.81 m/s\u00b2 Measured value: 9.55 \u00b1 0.18 m/s\u00b2 Phyton import numpy as np import matplotlib.pyplot as plt # Simulated 10 measurements of time for 10 oscillations (seconds) T10_measurements = np.array([20.4, 20.2, 20.5, 20.3, 20.4, 20.2, 20.3, 20.4, 20.1, 20.3]) # Pendulum length (meters) L = 1.000 delta_L = 0.005 # uncertainty in length (m) # Mean and standard deviation T10_mean = np.mean(T10_measurements) T10_std = np.std(T10_measurements, ddof=1) # sample std deviation delta_T10 = T10_std / np.sqrt(len(T10_measurements)) # Period and uncertainty T = T10_mean / 10 delta_T = delta_T10 / 10 # Gravitational acceleration g = (4 * np.pi**2 * L) / T**2 # Uncertainty in g delta_g = g * np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) # Print results print(f\"Mean time for 10 oscillations (T10): {T10_mean:.3f} \u00b1 {delta_T10:.3f} s\") print(f\"Period (T): {T:.3f} \u00b1 {delta_T:.3f} s\") print(f\"Calculated g: {g:.3f} \u00b1 {delta_g:.3f} m/s\u00b2\") # --- Plot 1: T10 measurements with mean line --- plt.figure(figsize=(8, 4)) plt.plot(T10_measurements, 'o-', label='Measurements') plt.axhline(y=T10_mean, color='red', linestyle='--', label=f'Mean = {T10_mean:.2f}s') plt.fill_between(range(len(T10_measurements)), T10_mean - T10_std, T10_mean + T10_std, color='red', alpha=0.1, label='\u00b11\u03c3') plt.title(\"Time for 10 Oscillations\") plt.xlabel(\"Trial\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() # --- Plot 2: Convergence of g estimation --- g_estimates = (4 * np.pi**2 * L) / (T10_measurements / 10)**2 plt.figure(figsize=(8, 4)) plt.plot(g_estimates, 'o-', label='g estimates per trial') plt.axhline(y=g, color='green', linestyle='--', label=f'Average g = {g:.2f} m/s\u00b2') plt.axhline(y=9.81, color='black', linestyle=':', label='Standard g = 9.81 m/s\u00b2') plt.title(\"Estimation of g Over Trials\") plt.xlabel(\"Trial\") plt.ylabel(\"g (m/s\u00b2)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity, \\(g\\) , is a fundamental constant in physics. Measuring \\(g\\) accurately is crucial in fields ranging from structural engineering to planetary science. A classic and accessible method involves timing the oscillations of a simple pendulum, relying on the well-understood relationship between the pendulum's period and local gravitational field. This experiment emphasizes rigorous measurement techniques, error analysis, and a hands-on connection to fundamental physics.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"Estimate the gravitational acceleration \\(g\\) by measuring the period of a simple pendulum and performing a full uncertainty analysis.","title":"Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"String: 1.0\u20131.5 meters long Mass: e.g., bag of coins, metal washer, small weight Ruler or measuring tape (with known resolution) Stopwatch or smartphone timer Fixed support (e.g., hook, rod, table edge)","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-setup","text":"Construct the pendulum by tying the weight securely to one end of the string. Fix the other end to a support so that the pendulum can swing freely. Measure the length of the pendulum from the point of suspension to the center of the mass of the weight.","title":"1. Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#notation","text":"Let \\(L\\) be the length of the pendulum (in meters) \\[ \\Delta L = \\frac{\\text{(resolution of measuring tool)}}{2} \\]","title":"Notation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#sample-data-table","text":"Trial Time for 10 Oscillations ( \\(T_{10}\\) ) [s] 1 20.4 2 20.2 3 20.5 4 20.3 5 20.4 6 20.2 7 20.3 8 20.4 9 20.1 10 20.3 Let: Mean time: \\( \\bar{T}_{10} = \\frac{1}{10} \\sum T_{10} \\) Standard deviation: \\( \\sigma_{T} \\) Uncertainty in mean: \\( \\Delta \\bar{T}_{10} = \\frac{\\sigma_{T}}{\\sqrt{n}} \\) where \\(n = 10\\)","title":"Sample Data Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-period-of-one-oscillation","text":"\\[ T = \\frac{\\bar{T}_{10}}{10} \\] \\[ \\Delta T = \\frac{\\Delta \\bar{T}_{10}}{10} \\]","title":"1. Period of One Oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-gravitational-acceleration","text":"\\[ g = \\frac{4 \\pi^2 L}{T^2} \\]","title":"2. Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-uncertainty-in-g","text":"\\[ \\Delta g = g \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( \\frac{2 \\Delta T}{T} \\right)^2 } \\]","title":"3. Uncertainty in \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#results-summary","text":"Quantity Value Uncertainty Pendulum Length \\(L\\) 1.0000 m \u00b10.005 m Mean Time \\(T_{10}\\) 20.31 s \u00b10.10 s Period \\(T\\) 2.031 s \u00b10.010 s Calculated \\(g\\) 9.55 m/s\u00b2 \u00b10.18 m/s\u00b2","title":"Results Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#comparison","text":"Standard gravitational acceleration: 9.81 m/s\u00b2 Measured value: 9.55 \u00b1 0.18 m/s\u00b2","title":"Comparison"},{"location":"1%20Physics/7%20Measurements/Problem_1/#phyton","text":"import numpy as np import matplotlib.pyplot as plt # Simulated 10 measurements of time for 10 oscillations (seconds) T10_measurements = np.array([20.4, 20.2, 20.5, 20.3, 20.4, 20.2, 20.3, 20.4, 20.1, 20.3]) # Pendulum length (meters) L = 1.000 delta_L = 0.005 # uncertainty in length (m) # Mean and standard deviation T10_mean = np.mean(T10_measurements) T10_std = np.std(T10_measurements, ddof=1) # sample std deviation delta_T10 = T10_std / np.sqrt(len(T10_measurements)) # Period and uncertainty T = T10_mean / 10 delta_T = delta_T10 / 10 # Gravitational acceleration g = (4 * np.pi**2 * L) / T**2 # Uncertainty in g delta_g = g * np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) # Print results print(f\"Mean time for 10 oscillations (T10): {T10_mean:.3f} \u00b1 {delta_T10:.3f} s\") print(f\"Period (T): {T:.3f} \u00b1 {delta_T:.3f} s\") print(f\"Calculated g: {g:.3f} \u00b1 {delta_g:.3f} m/s\u00b2\") # --- Plot 1: T10 measurements with mean line --- plt.figure(figsize=(8, 4)) plt.plot(T10_measurements, 'o-', label='Measurements') plt.axhline(y=T10_mean, color='red', linestyle='--', label=f'Mean = {T10_mean:.2f}s') plt.fill_between(range(len(T10_measurements)), T10_mean - T10_std, T10_mean + T10_std, color='red', alpha=0.1, label='\u00b11\u03c3') plt.title(\"Time for 10 Oscillations\") plt.xlabel(\"Trial\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() # --- Plot 2: Convergence of g estimation --- g_estimates = (4 * np.pi**2 * L) / (T10_measurements / 10)**2 plt.figure(figsize=(8, 4)) plt.plot(g_estimates, 'o-', label='g estimates per trial') plt.axhline(y=g, color='green', linestyle='--', label=f'Average g = {g:.2f} m/s\u00b2') plt.axhline(y=9.81, color='black', linestyle=':', label='Standard g = 9.81 m/s\u00b2') plt.title(\"Estimation of g Over Trials\") plt.xlabel(\"Trial\") plt.ylabel(\"g (m/s\u00b2)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Phyton"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}